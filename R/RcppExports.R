# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate the correlation structure based statistics
#'
#' Both of the "concordance of correlation structure" and "density of 
#' correlation structure" are calculated using all pairwise 
#' correlation coefficients between nodesin both the \emph{discovery} and 
#' \emph{test} datasets. For the other module preservation statistics we can
#' store components of each statistic calculated in each dataset separately,
#' and save time by only calculating them in the discovery dataset once. 
#' This would have a substantial memory overhead for the correlation structure
#' based statistics, so we don't use this strategy.
#' 
#' @param pCorD,pCorT SEXP containers for the pointers to the correlation 
#'  structure matrices for the \emph{discovery} and \emph{test} networks.
#' @param discIndices,testIndices indices of the network subset in
#'   the \emph{discovery} and \emph{test} networks respectively.
#'
#' @return
#'   A vector containing:
#'   \enumerate{
#'     \item{\emph{cor.discovery}:}{
#'       A flattened vector of the module's correlation structure in the 
#'       \emph{discovery} dataset.
#'     }
#'     \item{\emph{cor.test}:}{
#'       A flattened vector of the module's correlation structure in the 
#'       \emph{test} dataset.
#'     }
#'     \item{\emph{corDensity}:}{
#'       The mean sign-aware correlation structure density of the network module.
#'     }
#'   }
#'   
#' @references
#'   \enumerate{
#'     \item{
#'       Langfelder, P., Luo, R., Oldham, M. C. & Horvath, S. \emph{Is my 
#'       network module preserved and reproducible?} PLoS Comput. Biol. 
#'       \strong{7}, e1001057 (2011). 
#'     }
#'  }
#' @rdname CorStats-cpp
CorStats <- function(pCorD, discIndices, pCorT, testIndices) {
    .Call('NetRep_CorStats', PACKAGE = 'NetRep', pCorD, discIndices, pCorT, testIndices)
}

#' Calculate the topological properties based on network edge weights
#'
#' @param pAdjacency SEXP container for the pointer to the adjacency matrix of
#'   the interaction network.
#' @param subsetIndices indices of the network subset of interest.
#'   
#' @return
#'   A List containing:
#'   \enumerate{
#'     \item{\emph{weightedDegree}:}{The weighted within-module degree for each node.}
#'     \item{\emph{averageEdgeWeight}:}{The mean absolute edge weight of the network subset.}
#'   }
#' @rdname NetProps-cpp
NetProps <- function(pAdjacency, subsetIndices) {
    .Call('NetRep_NetProps', PACKAGE = 'NetRep', pAdjacency, subsetIndices)
}

#' Get the range of a big.matrix
#' 
#' @description
#'  \code{RangeSubset}: get the range of values in the column-subset of a 
#'  big.matrix.
#' 
#' @param pDat SEXP container for the pointer to the data matrix to be scaled.
#' @param subsetIndices indices of the network subset of interest in 
#'   \code{pDat}.
#'   
#' @rdname range-cpp
RangeSubset <- function(pDat, subsetIndices) {
    .Call('NetRep_RangeSubset', PACKAGE = 'NetRep', pDat, subsetIndices)
}

#' @name range-cpp
#' @description
#'   \code{BigRange}: get the range of values in a big.matrix
#' 
BigRange <- function(pDat) {
    .Call('NetRep_BigRange', PACKAGE = 'NetRep', pDat)
}

#' Check the elements of a `big.matrix`
#' 
#' Are all the values finite? 
#' 
#' @param pDat SEXP container for the pointer to the 
#'   \code{\link[bigmemory]{big.matrix}} to be checked.
#'
#' @rdname chekcFinite-cpp
CheckFinite <- function(pDat) {
    invisible(.Call('NetRep_CheckFinite', PACKAGE = 'NetRep', pDat))
}

#' Get the module summary vector and the proportion of variance it explains
#' 
#' @param pDat SEXP container for the pointer to a scaled version of the 
#'   data matrix used to construct the network.
#' @param subsetIndices indices of the network subset of interest in 
#'   \code{pDat}.
#' 
#' @return
#'  A list containing:
#'  \enumerate{
#'   \item{\emph{"moduleSummary"}:}{
#'     The module's summary profile (see details).
#'   }
#'   \item{\emph{"nodeContribution"}:}{
#'     The contribution of each node to the module's summary profile (see 
#'     details).
#'   }
#'   \item{\emph{"moduleCoherence"}:}{
#'     The proportion of the variance in the data explained by the module's 
#'     summary profile (see details).
#'   }
#'  }
#'  
#' @references
#'  \enumerate{
#'     \item{
#'       Langfelder, P., Luo, R., Oldham, M. C. & Horvath, S. \emph{Is my
#'       network module preserved and reproducible?} PLoS Comput. Biol. 
#'       \strong{7}, e1001057 (2011). 
#'     }
#'  }
#'  
#' @details
#'  First, the module summary profile ('moduleSummary') is calculated as the
#'  first eigenvector of a principal component analysis of the variables
#'  composing the module of interest. The orientation of the eigenvector is
#'  modified so that its sign is in the same direction as the module on
#'  average. I.e. for gene expression data this is the "module eigengene"
#'  \emph{(1)}.
#'  
#'  Each node's contribution to the summary profile ('nodeContribution') is
#'  quantified as the correlation between each variable composing the module
#'  and the module's summary profile. For weighted gene coexpression networks,
#'  this is typically referred to as the 'module membership' \emph{(1)}.
#'  
#'  The The proportion of module variance explained by the summary profile
#'  ('moduleCoherence') is quantified as the average square of the
#'  'nodeContribution' \emph{(1)}.
#' 
#' @import RcppArmadillo
#' @rdname dataProps-cpp
#'  
DataProps <- function(pDat, subsetIndices) {
    .Call('NetRep_DataProps', PACKAGE = 'NetRep', pDat, subsetIndices)
}

#' Multithreaded permutation procedure for module preservation statistics
#' 
#' @details
#' \subsection{Input expectations:}{
#'   Note that this function expects all inputs to be sensible, as checked by
#'   the R function 'checkUserInput' and processed by 'modulePreservation'. 
#'   
#'   These requirements are:
#'   \itemize{
#'   \item{The ordering of node names across 'dData', 'dCorr', and 'dNet' is
#'         consistent.}
#'   \item{The ordering of node names across 'tData', 'tCorr', and 'tNet' is
#'         consistent.}
#'   \item{The columns of 'dData' and 'tData' are the nodes.}
#'   \item{'dCorr', 'dNet', 'tCorr', and 'tNet' are square matrices, and their
#'         rownames are identical to their column names.}
#'   \item{'moduleAssigments' is a named character vector, where the names
#'         represent node labels found in the discovery dataset (e.g. 'dNet').}
#'   \item{'nPermutations' is a single number, greater than 0.}
#'   \item{'nCores' is a single number, greater than 0. Note, this number must
#'         not be larger than the number of cores on your machine, or the 
#'         number of cores allocated to your job!}
#'   \item{'nullHypothesis' must be a character vector of length 1, containing
#'         either "overlap" or "all".}
#'   \item{'verbose' must be a logical vector of length 1 containing either 
#'         'TRUE' or 'FALSE'.}
#'   \item{'vCat' must be the function NetRep:::vCat.}
#'   }
#' }
#' 
#' @param dData data matrix from the \emph{discovery} dataset.
#' @param dCorr matrix of correlation coefficients between all pairs of 
#'   variables/nodes in the \emph{discovery} dataset.
#' @param dNet adjacency matrix of network edge weights between all pairs of 
#'   nodes in the \emph{discovery} dataset.
#' @param tData data matrix from the \emph{test} dataset.
#' @param tCorr matrix of correlation coefficients between all pairs of 
#'   variables/nodes in the \emph{test} dataset.
#' @param tNet adjacency matrix of network edge weights between all pairs of 
#'   nodes in the \emph{test} dataset.
#' @param moduleAssignments a named character vector containing the module 
#'   each node belongs to in the discovery dataset. 
#' @param modules a character vector of modules for which to calculate the 
#'   module preservation statistics.
#' @param nPermutations the number of permutations from which to generate the
#'   null distributions for each statistic.
#' @param nCores the number of cores that the permutation procedure may use.
#' @param nullHypothesis either "overlap" or "all".
#' @param verbose if 'true', then progress messages are printed.
#' @param vCat the vCat function must be passed in so that it can be called 
#'  for output logging. 
#' 
#' @return a list containing a matrix of observed test statistics, and an
#'   array of null distribution observations.
PermutationProcedure <- function(dData, dCorr, dNet, tData, tCorr, tNet, moduleAssignments, modules, nPermutations, nCores, nullHypothesis, verbose, vCat) {
    .Call('NetRep_PermutationProcedure', PACKAGE = 'NetRep', dData, dCorr, dNet, tData, tCorr, tNet, moduleAssignments, modules, nPermutations, nCores, nullHypothesis, verbose, vCat)
}

#' Multithreaded permutation procedure for module preservation statistics
#' 
#' @details
#' \subsection{Input expectations:}{
#'   Note that this function expects all inputs to be sensible, as checked by
#'   the R function 'checkUserInput' and processed by 'modulePreservation'. 
#'   
#'   These requirements are:
#'   \itemize{
#'   \item{The ordering of node names across dCorr' and 'dNet' is consistent.}
#'   \item{The ordering of node names across 'tCorr' and 'tNet' is consistent.}
#'   \item{'dCorr', 'dNet', 'tCorr', and 'tNet' are square matrices, and their
#'         rownames are identical to their column names.}
#'   \item{'moduleAssigments' is a named character vector, where the names
#'         represent node labels found in the discovery dataset (e.g. 'dNet').}
#'   \item{'nPermutations' is a single number, greater than 0.}
#'   \item{'nCores' is a single number, greater than 0. Note, this number must
#'         not be larger than the number of cores on your machine, or the 
#'         number of cores allocated to your job!}
#'   \item{'nullHypothesis' must be a character vector of lenght 1, containing
#'         either "overlap" or "all".}
#'   \item{'verbose' must be a logical vector of length 1 containing either 
#'         'TRUE' or 'FALSE'.}
#'   \item{'vCat' must be the function NetRep:::vCat.}
#'   }
#' }
#' 
#' @param dCorr matrix of correlation coefficients between all pairs of 
#'   variables/nodes in the \emph{discovery} dataset.
#' @param dNet adjacency matrix of network edge weights between all pairs of 
#'   nodes in the \emph{discovery} dataset.
#' @param tCorr matrix of correlation coefficients between all pairs of 
#'   variables/nodes in the \emph{test} dataset.
#' @param tNet adjacency matrix of network edge weights between all pairs of 
#'   nodes in the \emph{test} dataset.
#' @param moduleAssignments a named character vector containing the module 
#'   each node belongs to in the discovery dataset. 
#' @param modules a character vector of modules for which to calculate the 
#'   module preservation statistics.
#' @param nPermutations the number of permutations from which to generate the
#'   null distributions for each statistic.
#' @param nCores the number of cores that the permutation procedure may use.
#' @param nullHypothesis either "overlap" or "all".
#' @param verbose if 'true', then progress messages are printed.
#' @param vCat the vCat function must be passed in so that it can be called 
#'  for output logging. 
#' 
#' @return a list containing a matrix of observed test statistics, and an
#'   array of null distribution observations.
PermutationProcedureNoData <- function(dCorr, dNet, tCorr, tNet, moduleAssignments, modules, nPermutations, nCores, nullHypothesis, verbose, vCat) {
    .Call('NetRep_PermutationProcedureNoData', PACKAGE = 'NetRep', dCorr, dNet, tCorr, tNet, moduleAssignments, modules, nPermutations, nCores, nullHypothesis, verbose, vCat)
}

#' Calculate the network properties 
#' 
#' @details
#' \subsection{Input expectations:}{
#'   Note that this function expects all inputs to be sensible, as checked by
#'   the R function 'checkUserInput' and processed by 'networkProperties'. 
#'   
#'   These requirements are:
#'   \itemize{
#'   \item{The ordering of node names across 'data' and 'net' is consistent.}
#'   \item{The columns of 'data' are the nodes.}
#'   \item{'net' is a square matrix, and its rownames are identical to its 
#'         column names.}
#'   \item{'moduleAssigments' is a named character vector, where the names
#'         represent node labels found in the discovery dataset. Unlike 
#'         'PermutationProcedure', these may include nodes that are not 
#'         present in 'data' and 'net'.}
#'   \item{The module labels specified in 'modules' must occur in 
#'         'moduleAssignments'.}
#'   }
#' }
#' 
#' @param data data matrix from the dataset in which to calculate the network
#'   properties.
#' @param net adjacency matrix of network edge weights between all pairs of 
#'   nodes in the dataset in which to calculate the network properties.
#' @param moduleAssignments a named character vector containing the module 
#'   each node belongs to in the discovery dataset. 
#' @param modules a character vector of modules for which to calculate the 
#'   network properties for.
#' 
#' @return a list containing the summary profile, node contribution, module
#'   coherence, weighted degree, and average edge weight for each 'module'.
NetworkProperties <- function(data, net, moduleAssignments, modules) {
    .Call('NetRep_NetworkProperties', PACKAGE = 'NetRep', data, net, moduleAssignments, modules)
}

#' Calculate the network properties, data matrix not provided
#' 
#' @details
#' \subsection{Input expectations:}{
#'   Note that this function expects all inputs to be sensible, as checked by
#'   the R function 'checkUserInput' and processed by 'networkProperties'. 
#'   
#'   These requirements are:
#'   \itemize{
#'   \item{'net' is a square matrix, and its rownames are identical to its 
#'         column names.}
#'   \item{'moduleAssigments' is a named character vector, where the names
#'         represent node labels found in the discovery dataset. Unlike 
#'         'PermutationProcedure', these may include nodes that are not 
#'         present in 'data' and 'net'.}
#'   \item{The module labels specified in 'modules' must occur in 
#'         'moduleAssignments'.}
#'   }
#' }
#' 
#' @param net adjacency matrix of network edge weights between all pairs of 
#'   nodes in the dataset in which to calculate the network properties.
#' @param moduleAssignments a named character vector containing the module 
#'   each node belongs to in the discovery dataset. 
#' @param modules a character vector of modules for which to calculate the 
#'   network properties for.
#' 
#' @return a list containing the summary profile, node contribution, module
#'   coherence, weighted degree, and average edge weight for each 'module'.
NetworkPropertiesNoData <- function(net, moduleAssignments, modules) {
    .Call('NetRep_NetworkPropertiesNoData', PACKAGE = 'NetRep', net, moduleAssignments, modules)
}

#' Scale a matrix by its rows
#' 
#' @param pDat SEXP container for the pointer to the data matrix to be scaled.
#' @param spDat SEXP container for the pointer to the pre-initialised
#'   \code{\link[bigmemory]{big.matrix}} that the scaled version of \code{pDat}
#'   will be stored in.
#' @rdname scale-cpp
Scale <- function(pDat, spDat) {
    invisible(.Call('NetRep_Scale', PACKAGE = 'NetRep', pDat, spDat))
}

