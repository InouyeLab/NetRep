# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Check the elements of a `big.matrix`
#' 
#' Are all the values finite? 
#' 
#' @param pDat SEXP container for the pointer to the 
#'   \code{\link[bigmemory]{big.matrix}} to be checked.
#'
#' @rdname chekcFinite-cpp
CheckFinite <- function(pDat) {
    invisible(.Call('NetRep_CheckFinite', PACKAGE = 'NetRep', pDat))
}

#' Calculate the correlation based statistics
#'
#' Both of the correlation statistics are calculated using all pairwise 
#' correlation values in both the \emph{discovery} and \emph{test} datasets.
#' For the other statistics, it makes sense to calculate the 
#' properties for the discovery network in advance to reduce calculation time
#' and memory. However, for the correaltion statistics this strategy doesn't 
#' make sense since we'd have to store a huge component of the discovery 
#' correlation structure.
#'
#' @param pCorD,pCorT SEXP containers for the pointers to the correlation 
#'  structure matrices for the \emph{discovery} and \emph{test} networks.
#' @param discIndices,testIndices indices of the network subset in
#'   the \emph{discovery} and \emph{test} networks respectively.
#'
#' @return
#'   A vector containing:
#'   \enumerate{
#'     \item{\emph{cor.discovery}:}{
#'       A flattened vector of the module's correlation structure in the 
#'       \emph{discovery} dataset.
#'     }
#'     \item{\emph{cor.test}:}{
#'       A flattened vector of the module's correlation structure in the 
#'       \emph{test} dataset.
#'     }
#'     \item{\emph{mean.cor}:}{
#'       The mean sign-aware correlation density of the network module.
#'     }
#'   }
#'   
#' @references
#'   \enumerate{
#'     \item{
#'       Langfelder, P., Luo, R., Oldham, M. C. & Horvath, S. \emph{Is my 
#'       network module preserved and reproducible?} PLoS Comput. Biol. 
#'       \strong{7}, e1001057 (2011). 
#'     }
#'  }
#' @rdname CorStats-cpp
CorStats <- function(pCorD, discIndices, pCorT, testIndices) {
    .Call('NetRep_CorStats', PACKAGE = 'NetRep', pCorD, discIndices, pCorT, testIndices)
}

#' Get the module summary vector and the proportion of variance it explains
#' 
#' @param pDat SEXP container for the pointer to a scaled version of the 
#'   data matrix used to construct the network.
#' @param subsetIndices indices of the network subset of interest in 
#'   \code{pDat}.
#' 
#' @return
#'  A list containing:
#'  \enumerate{
#'   \item{\emph{"moduleSummary"}:}{
#'     The module summary profile (see details).
#'   }
#'   \item{\emph{"MM"}:}{
#'     The Module Membership of each node (see details).
#'   }
#'   \item{\emph{"pve"}:}{
#'     The proportion of the variance explained by the module's summary 
#'      profile (see details).
#'   }
#'  }
#'  
#' @references
#'  \enumerate{
#'     \item{
#'       Langfelder, P., Luo, R., Oldham, M. C. & Horvath, S. \emph{Is my
#'       network module preserved and reproducible?} PLoS Comput. Biol. 
#'       \strong{7}, e1001057 (2011). 
#'     }
#'  }
#'  
#' @details
#'  First, the module summary profile (SP) is calculated as the first 
#'  eigenvector of a principal component analysis of the variables composing 
#'  the module of interest. The orientation of the eigenvector is modified so 
#'  that its sign is in the same direction as the module on average. I.e. for 
#'  gene expression data this is the "module eigengene" \emph{(1)}.
#'  
#'  The Module Membership (MM) is the correlation between each variable 
#'  composing the module and the module's summary profile.
#'  
#'  The proportion of module variance explained by the summary profile (pve) 
#'  is quantified as the average square of the Module Membership \emph{(1)}.
#' 
#' @import RcppArmadillo
#' @rdname dataProps-cpp
#'  
DataProps <- function(pDat, subsetIndices) {
    .Call('NetRep_DataProps', PACKAGE = 'NetRep', pDat, subsetIndices)
}

#' Calculate Mean Adjacency and Intramodular Connectivity
#'
#' @param pAdjacency SEXP container for the pointer to the adjacency matrix.
#' @param subsetIndices indices of the network subset of interest.
#'   
#' @return
#'   A List containing:
#'   \enumerate{
#'     \item{\emph{kIM}:}{The weighted within-subset degree for each node.}
#'     \item{\emph{mean.adj}:}{The mean absolute edge weight of the network subset.}
#'   }
#' @rdname NetProps-cpp
NetProps <- function(pAdjacency, subsetIndices) {
    .Call('NetRep_NetProps', PACKAGE = 'NetRep', pAdjacency, subsetIndices)
}

#' Get the range of a big.matrix
#' 
#' @description
#'  \code{RangeSubset}: get the range of values in the column-subset of a 
#'  big.matrix.
#' 
#' @param pDat SEXP container for the pointer to the data matrix to be scaled.
#' @param subsetIndices indices of the network subset of interest in 
#'   \code{pDat}.
#'   
#' @rdname range-cpp
RangeSubset <- function(pDat, subsetIndices) {
    .Call('NetRep_RangeSubset', PACKAGE = 'NetRep', pDat, subsetIndices)
}

#' @name range-cpp
#' @description
#'   \code{BigRange}: get the range of values in a big.matrix
#' 
BigRange <- function(pDat) {
    .Call('NetRep_BigRange', PACKAGE = 'NetRep', pDat)
}

#' Scale a matrix by its rows
#' 
#' @param pDat SEXP container for the pointer to the data matrix to be scaled.
#' @param spDat SEXP container for the pointer to the pre-initialised
#'   \code{\link[bigmemory]{big.matrix}} that the scaled version of \code{pDat}
#'   will be stored in.
#' @rdname scale-cpp
Scale <- function(pDat, spDat) {
    invisible(.Call('NetRep_Scale', PACKAGE = 'NetRep', pDat, spDat))
}

