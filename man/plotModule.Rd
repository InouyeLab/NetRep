% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot-module.R
\name{plotModule}
\alias{plotModule}
\title{Plot the topology of a network module}
\usage{
plotModule(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderSamplesBy = "test",
  orderNodesBy = "discovery", orderModules = TRUE, plotNodeNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames, main = "Module Topology",
  drawBorders = FALSE, border.width = 2, gaxt.line = -0.5,
  saxt.line = -0.5, maxt.line, legend.tick.size = 0.04, laxt.line = 2.5,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)
}
\arguments{
\item{data}{a list of numeric matrices. Each entry of the list corresponds to
a dataset and contains the data used to infer the interaction network
between variables (e.g. genes). Expects matrix columns to correspond to
variables and matrix rows to correspond to samples.}

\item{correlation}{a list of matrices. Each entry of the list corresponds to a 
dataset and contains an \eqn{n * n} matrix of the correlation between 
each pair of variables in the dataset.}

\item{network}{a list of matrices. Each entry of the list corresponds to a 
dataset and contains an \eqn{n * n} matrix of the network edge weights 
between each pair of variables in the dataset.}

\item{moduleAssignments}{a vector containing the module each variable belongs
to in the discovery dataset. If there are multiple discovery datasets 
then this argument should be a list of such vectors.}

\item{modules}{a list of vectors, one for each \code{discovery} dataset, 
of modules to perform the analysis on. The default is to analyse all modules
in each \code{discovery} dataset, with the exception of those specified in 
\code{backgroundLabel}.}

\item{backgroundLabel}{a single label that nodes that do not belong to any
module are assigned. The default is "0".}

\item{discovery}{a vector of names or indices denoting the discovery dataset(s).}

\item{test}{a list of vectors of names or indices denoting the test datasets
for each \code{discovery} dataset. Alternatively can be provided as vector
if the test datasets are the same for all 'discovery' datasets (e.g. for 
performing a pairwise comparison).}

\item{nCores}{number of cores to parallelise the calculation of network 
properties over. Ignored if the user has already registered a parallel 
backend.If \code{NULL} (default) the maximum number of cores on the machine
will be used.}

\item{verbose}{logical; should progress be reported? Default is \code{TRUE}.}

\item{orderSamplesBy}{one of "discovery", "test" or "none". Controls how 
samples are ordered on the plot (see details).}

\item{orderNodesBy}{one of "discovery", "test" or "none". Controls how nodes
are ordered on the plot (see details).}

\item{orderModules}{logical; if \code{TRUE} modules ordered by clustering 
their summary vectors. If \code{FALSE} modules are returned in the order
provided.}

\item{plotNodeNames}{logical; controls whether the node names are 
rendered on the bottom axis.}

\item{plotSampleNames}{logical; controls whether the sample names are 
rendered on the left axis.}

\item{plotModuleNames}{logical; controls whether module names are rendered.
The default is for module names to be rendered when multiple \code{modules} 
are drawn.}

\item{main}{title for the plot.}

\item{drawBorders}{logical; if \code{TRUE}, borders are drawn around the 
connectivity, module membership, and module summary bar plots.}

\item{border.width}{line width for borders.}

\item{gaxt.line}{the number of lines into the bottom margin at which the node
names will be drawn.}

\item{saxt.line}{the number of lines into the left margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the bottom margin at which the 
module names will be drawn.}

\item{legend.tick.size}{size of the ticks on each axis legend relative to the
size of the correlation, edge weights, and data matrix heatmaps.}

\item{laxt.line}{the distance from the legend to render the legend axis 
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the node and sample names.}

\item{cex.lab}{relative size of the module names and legend titles.}

\item{cex.main}{relative size of the plot titles.}
}
\description{
Plot the correlation structure, network edges, (normalised) connectivity, 
module membership, underlying data, and module summary vector of one or
more network modules.

Individual components of the module plot can be plotted using 
\code{\link{plotCorrelation}}, \code{\link{plotNetwork}}, 
\code{\link{plotDegree}}, \code{\link{plotContribution}}, 
\code{\link{plotData}}, and \code{\link{plotSummary}}.
}
\details{
\subsection{Input data structure:}{
  The \link[=modulePreservation]{preservation of network modules} in a second
  dataset is quantified by measuring the preservation of topological
  properties between the \emph{discovery} and \emph{test} datasets. These 
  properties are calculated not only from the interaction networks inferred
  in each dataset, but also from the data used to infer those networks (e.g.
  gene expression data) as well as the correlation structure between 
  variables/nodes. Thus, all functions in the \code{NetRep} package have the 
  following arguments: 
  \itemize{
    \item{\code{network}:}{
      a list of interaction networks, one for each dataset.
    }
    \item{\code{data}:}{
      a list of data matrices used to infer those networks, one for each 
      dataset.
    }
    \item{\code{correlation}:}{
     a list of matrices containing the pairwise correlation coefficients 
     between variables/nodes in each dataset.
    } 
    \item{\code{moduleAssignments}:}{
     a list of vectors, one for each \emph{discovery} dataset, containing 
     the module assignments for each node in that dataset.
    }
    \item{\code{modules}:}{
     a list of vectors, one for each \emph{discovery} dataset, containing
     the names of the modules from that dataset to analyse.  
    }
    \item{\code{discovery}:}{
      a vector indicating the names or indices of the previous arguments' 
      lists to use as the \emph{discovery} dataset(s) for the analyses.
    }
    \item{\code{test}:}{
      a list of vectors, one vector for each \emph{discovery} dataset, 
      containing the names or indices of the \code{network}, \code{data}, and 
      \code{correlation} argument lists to use as the \emph{test} dataset(s) 
      for the analysis of each \emph{discovery} dataset.
    }
  }
  
  The formatting of these arguments is not strict: each function will attempt
  to make sense of the user input. For example, if there is only one 
  \code{discovery} dataset, then input to the \code{moduleAssigments} and 
  \code{test} arguments may be vectors, rather than lists. If the node and
  sample ordering is being calculated within the same dataset being 
  visualised, then the \code{discovery} and \code{test} arguments do
  not need to be specified, and the input matrices for the \code{network},
  \code{data}, and \code{correlation} arguments do not need to be wrapped in
  a list.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link{bigMatrix}} 
  data, regular 'matrix' objects are also accepted. In this case, the 
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on 
  disk, which can take a long time for large datasets. It is strongly 
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link[=plotModule]{plotting} 
  \link[=plotTopology]{functions}, \link[=nodeOrder]{node} and 
  \link[=sampleOrder]{sample} ordering functions also expect 'bigMatrix'
  objects. Further, 'bigMatrix' objects have a number of benefits, including 
  instantaneous load time from any future R session, and parallel access from
  mutliple independent R sessions. Methods are provided for 
  converting to, loading in, and writing out \code{\link{bigMatrix}} objects.
}
\subsection{Node, sample, and module ordering:}{
  By default, nodes are ordered in decreasing order of \emph{weighted degree}
  in the \code{discovery} dataset (see \code{\link{nodeOrder}}). 
  This facilitates the visual comparison of modules across datasets, as the 
  node ordering will be preserved. Missing nodes are colored in grey. If
  \code{orderNodesBy} is "test" nodes will instead be ordered by 
  weighted degree in the \code{test} dataset. If "none" nodes are 
  drawn in the order they are provided in the drawn dataset.
  
  When multiple modules are specified, modules are ordered by the similarity
  of their summary vectors in the drawn dataset. To disable this behaviour, 
  set \code{orderModules} to \code{FALSE}.
  
  Sample ordering only applies to \code{plotData} and 
  \code{plotModuleSummary}. By default, samples are ordered in descending
  order of the module summary vector in the drawn dataset for the left-most 
  module appearing on the plot (see \code{\link{sampleOrder}}.
}
\subsection{Normalised degree:}{
  The weighted degree is normalised by the maximum connectivity in
  any given module when rendered on the bar plot. This facilitates visual 
  comparison of multiple modules with differing sizes or densities.
}
\subsection{Plot customisation:}{
  Although reasonable default values for most parameters have been provided,
  the rendering of axes and titles may need adjusting depending on the size
  of the plot window. The parameters \code{gaxt.line}, \code{saxt.line}, 
  \code{maxt.line}, and \code{laxt.line} control the distance from each plot
  window that the node labels, sample labels, module labels, and legend 
  labels are rendered. 
  
  \code{legend.tick.size} controls the length of the 
  axis ticks on each of the legends relative to the correlation, edge weight,
  and data matrix heatmap plot windows. 
  
  \code{cex.main} controls the relative text size of the plot title
  (specified by the \code{main} argument). \code{cex.axis} controls the
  relative text size of the node and sample labels. \code{cex.lab} controls
  the relative text size of the bar plot axis labels, module labels, and the
  legend titles.
  
  The rendering of node, sample, and module names can be disabled by setting
  \code{plotNodeNames}, \code{plotSampleNames}, and \code{plotModuleNames} to
  \code{FALSE}.
  
  The \code{drawBorders} argument controls whether borders are drawn around
  the connectivity, module membership, or module summary bar plots.
}
}
\examples{
\dontrun{
# load in example data, correlation, and network matrices for a discovery and test dataset:
data("NetRep")

# Convert them to the 'bigMatrix' format:
discovery_data <- as.bigMatrix(discovery_data)
discovery_correlation <- as.bigMatrix(discovery_correlation)
discovery_network <- as.bigMatrix(discovery_network)
test_data <- as.bigMatrix(test_data)
test_correlation <- as.bigMatrix(test_correlation)
test_network <- as.bigMatrix(test_network)

# Set up input lists for each input matrix type across datasets:
data_list <- list(discovery=discovery_data, test=test_data)
correlation_list <- list(discovery=discovery_correlation, test=test_correlation)
network_list <- list(discovery=discovery_network, test=test_network)
labels_list <- list(discovery=module_labels)

# Plot module 1, 2 and 4in the discovery dataset
plotModule(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4)
)

# Now plot them in the test dataset (module 2 does not replicate)
plotModule(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), discovery="discovery",
  test="test"
)
}

}
\seealso{
\code{\link{plotCorrelation}}, 
\code{\link{plotNetwork}},
\code{\link{plotDegree}},
\code{\link{plotContribution}},
\code{\link{plotData}}, and
\code{\link{plotSummary}}.
}

