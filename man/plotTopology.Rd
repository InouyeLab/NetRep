% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot-topology.R
\name{plotTopology}
\alias{plotContribution}
\alias{plotCorrelation}
\alias{plotCorrelationLegend}
\alias{plotData}
\alias{plotDataLegend}
\alias{plotDegree}
\alias{plotNetwork}
\alias{plotNetworkLegend}
\alias{plotSummary}
\alias{plotTopology}
\title{Plot a topological feature of network module}
\usage{
plotData(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderSamplesBy = NULL,
  orderNodesBy = NULL, orderModules = TRUE, plotNodeNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames = NULL, main = "",
  palette = NULL, border.width = 2, plotLegend = TRUE,
  legend.main = "Data", gaxt.line = -0.5, saxt.line = -0.5,
  maxt.line = 3, legend.position = 0.15, legend.tick.size = 0.03,
  laxt.line = 3, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCorrelation(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderNodesBy = NULL, symmetric = FALSE,
  orderModules = TRUE, plotNodeNames = TRUE, plotModuleNames = NULL,
  main = "", palette = NULL, border.width = 2, plotLegend = TRUE,
  legend.main = "Correlation", gaxt.line = -0.5, maxt.line = 3,
  legend.position = NULL, legend.tick.size = NULL, laxt.line = NULL,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotNetwork(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderNodesBy = NULL, symmetric = FALSE,
  orderModules = TRUE, plotNodeNames = TRUE, plotModuleNames = NULL,
  main = "", palette = NULL, border.width = 2, plotLegend = TRUE,
  legend.main = "Edge weight", gaxt.line = -0.5, maxt.line = 3,
  legend.position = NULL, legend.tick.size = NULL, laxt.line = NULL,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotContribution(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderNodesBy = NULL,
  orderModules = TRUE, plotNodeNames = TRUE, plotModuleNames = NULL,
  main = "", border.width = 2, palette = NULL, drawBorders = FALSE,
  gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)

plotDegree(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderNodesBy = NULL,
  orderModules = TRUE, plotNodeNames = TRUE, plotModuleNames = NULL,
  main = "", palette = NULL, border.width = 2, drawBorders = FALSE,
  gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)

plotSummary(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  nCores = NULL, verbose = TRUE, orderSamplesBy = NULL,
  orderNodesBy = NULL, orderModules = TRUE, plotSampleNames = TRUE,
  plotModuleNames = NULL, main = "", palette = c("#762a83", "#1b7837"),
  border.width = 2, drawBorders = FALSE, saxt.line = -0.5,
  maxt.line = 0, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotDataLegend(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = NULL, test = NULL,
  verbose = TRUE, palette = NULL, border.width = 2, horizontal = TRUE,
  legend.main = "Data", legend.tick.size = 0.03, laxt.line = 2.5,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCorrelationLegend(palette = NULL, border.width = 2, horizontal = TRUE,
  legend.main = "correlation", legend.tick.size = 0.03, laxt.line = 2.5,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2, verbose = TRUE)

plotNetworkLegend(palette = network.palette(), border.width = 2,
  horizontal = TRUE, legend.main = "network", legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2,
  verbose = TRUE)
}
\arguments{
\item{data}{a list of matrices, one for each dataset. Each 
entry of the list should be a numeric \code{\link{bigMatrix}} of data used
to infer the interaction network for that dataset. The columns should
correspond to variables in the data (nodes in the network) and rows to 
samples in that dataset.}

\item{correlation}{a list of matrices, one for each dataset. Each entry of
the list should be a \eqn{n * n} numeric \code{\link{bigMatrix}} where each
element contains the correlation coefficient between nodes \eqn{i} and
\eqn{j} in data used to infer the interaction network for that dataset.}

\item{network}{a list of interaction networks, one for each dataset. Each 
entry of the list should be a \eqn{n * n} numeric \code{\link{bigMatrix}}
where each element contains the edge weight between nodes \eqn{i} and 
\eqn{j} in the inferred network for that dataset.}

\item{moduleAssignments}{a list of vectors, one for each \emph{discovery} 
dataset, containing the module assignments for each node in that dataset.}

\item{modules}{a list of vectors, one for each \code{discovery} dataset, 
of modules to perform the analysis on. If unspecified, all modules
in each \code{discovery} dataset will be analysed, with the exception of 
those specified in \code{backgroundLabel} argument.}

\item{backgroundLabel}{a single label given to nodes that do not belong to 
any module in the \code{moduleAssignments} argument.}

\item{discovery}{a vector of names or indices denoting the \emph{discovery}
dataset(s) in the \code{data}, \code{correlation}, \code{network}, 
\code{moduleAssignments}, \code{modules}, and \code{test} lists.}

\item{test}{a list of vectors, one for each \code{discovery} dataset,
of names or indices denoting the \emph{test} dataset(s) in the \code{data}, 
\code{correlation}, and \code{network} lists.}

\item{nCores}{number of cores to parallelise the calculation of network 
properties over. Ignored if the user has already registered a parallel 
backend. If \code{NULL} (default) the all but one core on the machine will
be used.}

\item{verbose}{logical; should progress be reported? Default is \code{TRUE}.}

\item{orderSamplesBy}{\code{NULL} (default), \code{NA}, or a vector 
containing a single dataset name or index. Controls how samples are ordered 
on the plot (see details).}

\item{orderNodesBy}{\code{NULL} (default), \code{NA}, or a vector of dataset
names or indices. Controls how nodes are ordered on the plot (see details).}

\item{orderModules}{logical; if \code{TRUE} modules ordered by clustering 
their summary vectors. If \code{FALSE} modules are returned in the order
provided.}

\item{plotNodeNames}{logical; controls whether the node names are 
rendered on the bottom axis.}

\item{plotSampleNames}{logical; controls whether the sample names are 
rendered on the left axis.}

\item{plotModuleNames}{logical; controls whether module names are rendered.
The default is for module names to be rendered when multiple \code{modules} 
are drawn.}

\item{main}{title for each plot.}

\item{palette}{a vector of colors to use for each plot (see details).}

\item{border.width}{line width for borders.}

\item{plotLegend}{logical; controls whether a legend is drawn when using
\code{plotCorrelation}, \code{plotNetwork}, or \code{plotData}.}

\item{legend.main}{title for the legend.}

\item{gaxt.line}{the number of lines into the bottom margin at which the node
names will be drawn.}

\item{saxt.line}{the number of lines into the left margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the bottom margin at which the 
module names will be drawn.}

\item{legend.position}{the distance from the plot to start the legend, as a
proportion of the plot width.}

\item{legend.tick.size}{size of the ticks on each axis legend relative to the
size of the correlation, edge weights, and data matrix heatmaps.}

\item{laxt.line}{the distance from the legend to render the legend axis 
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the node and sample names.}

\item{cex.lab}{relative size of the module names and legend titles.}

\item{cex.main}{relative size of the plot titles.}

\item{symmetric}{logical; controls whether the correlation and network 
heatmaps are drawn as symmetric (square) heatmaps or asymettric triangle 
heatmaps. If symmetric, then the node and module names will also be rendered
on the left axis.}

\item{drawBorders}{logical; if \code{TRUE}, borders are drawn around the bars
in \code{plotContribution}, \code{plotDegree}, and
\code{plotSummary}.}

\item{horizontal}{logical; controls whether the legend is rendered 
horizontally or vertically when using \code{plotDataLegend},
\code{plotCorrelationLegend} or \code{plotNetworkLegend}.}
}
\description{
Functions for plotting the topology of a network module.

\code{plotData}: Plot a heatmap of the data matrix for one or more
network modules.

\code{plotCorrelation}: Plot a heatmap of the correlation structure for one 
or more network modules.

\code{plotNetwork}: Plot a heatmap of the edge weights for one or more
network modules.

\code{plotContribution}: Plot a bar chart of the module membership for
one or more network modules.

\code{plotDegree:} Plot a bar chart of the scaled weighted degree 
(see details) for one or more network modules.

\code{plotSummary}: Plot bar charts of the module summary vectors of 
one or more network modules.

\code{plotDataLegend}: Plot a legend for the data matrix heatmap
for one or more network modules.

\code{plotCorrelationLegend}: Plot a legend for the correlation structure 
heatmap.

\code{plotNetworkLegend}: Plot a legend for the network edge weights heatmap.
}
\details{
\subsection{Input data structure:}{
  The \link[=modulePreservation]{preservation of network modules} in a second
  dataset is quantified by measuring the preservation of topological
  properties between the \emph{discovery} and \emph{test} datasets. These 
  properties are calculated not only from the interaction networks inferred
  in each dataset, but also from the data used to infer those networks (e.g.
  gene expression data) as well as the correlation structure between 
  variables/nodes. Thus, all functions in the \code{NetRep} package have the 
  following arguments: 
  \itemize{
    \item{\code{network}:}{
      a list of interaction networks, one for each dataset.
    }
    \item{\code{data}:}{
      a list of data matrices used to infer those networks, one for each 
      dataset.
    }
    \item{\code{correlation}:}{
     a list of matrices containing the pairwise correlation coefficients 
     between variables/nodes in each dataset.
    } 
    \item{\code{moduleAssignments}:}{
     a list of vectors, one for each \emph{discovery} dataset, containing 
     the module assignments for each node in that dataset.
    }
    \item{\code{modules}:}{
     a list of vectors, one for each \emph{discovery} dataset, containing
     the names of the modules from that dataset to analyse.  
    }
    \item{\code{discovery}:}{
      a vector indicating the names or indices of the previous arguments' 
      lists to use as the \emph{discovery} dataset(s) for the analyses.
    }
    \item{\code{test}:}{
      a list of vectors, one vector for each \emph{discovery} dataset, 
      containing the names or indices of the \code{network}, \code{data}, and 
      \code{correlation} argument lists to use as the \emph{test} dataset(s) 
      for the analysis of each \emph{discovery} dataset.
    }
  }
  
  The formatting of these arguments is not strict: each function will attempt
  to make sense of the user input. For example, if there is only one 
  \code{discovery} dataset, then input to the \code{moduleAssigments} and 
  \code{test} arguments may be vectors, rather than lists. If the node and
  sample ordering is being calculated within the same dataset being 
  visualised, then the \code{discovery} and \code{test} arguments do
  not need to be specified, and the input matrices for the \code{network},
  \code{data}, and \code{correlation} arguments do not need to be wrapped in
  a list.
}
\subsection{'bigMatrix' input data:}{
  Although the \code{data}, \code{correlation}, and \code{network} arguments 
  expect data to be provided in the \code{\link{bigMatrix}}, they can be 
  provided as regular \code{\link[base]{matrix}} objects, in which case they 
  will be temporarily converted to \code{bigMatrix} objects. \strong{This is 
  not recommended}, as each matrix will be copied into memory of each 
  parallel R session, resulting in much higher memory usage (see section on
  Memory usage ), and increased computation time for the conversion and
  copying processes. It is therefore strongly recommended that the user save
  their data separately as \code{\link{bigMatrix}} objects prior to running
  the permutation procedure or using any other package function. This is also
  useful for other analyses, as \code{bigMatrix} objects can be
  instantaneously loaded into any future R session.
  
  Alternatively, the \code{data}, \code{correlation}, and \code{network} 
  arguments will also accept file paths to tabular data or \code{bigMatrix} 
  backingfiles.
}
\subsection{Memory usage:}{
  Provided there are no additional objects in the R session the
  permutation procedure will use only the memory required to store each 
  matrix once, along with an additional 200 MB per core used by each vanilla
  R session.
}
\subsection{Node, sample, and module ordering:}{
  By default, nodes are ordered in decreasing order of \emph{weighted degree}
  in the \code{discovery} dataset (see \code{\link{nodeOrder}}). Missing 
  nodes are colored in grey. This facilitates the visual comparison of 
  modules across datasets, as the node ordering will be preserved. 
  
  Alternatively, a vector containing the names or indices of one or more
  datasets can be provided to the \code{orderNodesBy} argument. If a single
  dataset is provided, then nodes will be ordered in decreasing order of
  \emph{weighted degree} in that dataset. If multiple datasets are provided
  then the \emph{weighted degree} will be calculated in each dataset and
  nodes will be ordered in decreasing order of average weighted degree. This
  is useful for obtaining a robust ordering of nodes by importance across
  independent datasets where a module is reproducible.
  
  Ordering of nodes by \emph{weighted degree} can be suppressed by setting
  \code{orderNodesBy} to \code{NA}, in which case nodes will be ordered as in
  the matrices provided in the \code{data}, \code{correlation} and
  \code{network} arguments.
  
  When multiple modules are drawn, modules are ordered by the similarity
  of their summary vectors in the dataset(s) specified in \code{orderNodesBy}
  argument. If multiple datasets are provided to the \code{orderNodesBy}
  argument then the module summary vectors are concatenated across datasets.
  
  By default, samples in the data heatmap drawn by \code{plotData} and the 
  bar plot drawn by \code{plotModuleSummary} are ordered in descending order
  of \emph{module summary} in the drawn dataset (specified by the \code{test}
  argument). If multiple modules are drawn, samples are ordered as per the
  left-most module on the plot.
  
  Alternatively, a vector containing the name or index of another dataset may
  be provided to the \code{orderSamplesBy} argument. In this case, samples
  will be ordered in descending order of \emph{module summary} in the 
  specified dataset. This is useful when comparing different measurements 
  across samples, for example, gene expression data obtained from multiple 
  tissues samples across the same individuals. Samples that are not present 
  in the drawn dataset will be colored in grey.
  
  Order of samples by \emph{module summary} can be suppressed by setting 
  \code{orderSamplesBy} to \code{NA}, in which case samples will be order as
  in the matrix provided to the \code{data} argument for the drawn dataset.
}
\subsection{Normalised degree:}{
  The weighted degree is normalised by the maximum weighted degree in
  any given module when rendered on the bar plot. This facilitates visual 
  comparison of multiple modules with differing sizes or densities.
}
\subsection{Customising plot layout:}{
  Although reasonable default values for most parameters have been provided,
  the rendering of axes and titles may need adjusting depending on the size
  of the plot window. The parameters \code{gaxt.line}, \code{saxt.line}, 
  \code{maxt.line}, and \code{laxt.line} control the distance from each plot
  window that the node labels, sample labels, module labels, and legend 
  labels are rendered. 
  
  \code{legend.tick.size} controls the length of the 
  axis ticks on each of the legends relative to the correlation, network,
  and data plot windows. 
  
  \code{legend.position} controls the horizontal offset of the legend 
  relative to the plot. For the triangle heatmaps, (\code{symmetric=FALSE} in
  \code{plotCorrelation} and \code{plotNetwork}) this controls how far 
  left of the plot the legend starts as a proportion of the plot width. For
  the square heatmaps (\code{plotData}, and \code{symmetric=TRUE} in
  \code{plotCorrelation} and \code{plotNetwork}) this controls how far 
  right of the plot the legend starts as a proportion of the plot width.
  
  \code{cex.main} controls the relative text size of the plot title
  (specified by the \code{main} argument). \code{cex.axis} controls the
  relative text size of the node and sample labels. \code{cex.lab} controls
  the relative text size of the bar plot axis labels, module labels, and the
  legend titles.
  
  The rendering of node, sample, and module names can be disabled by setting
  \code{plotNodeNames}, \code{plotSampleNames}, and \code{plotModuleNames} to
  \code{FALSE}, and the rendering of the legend can be disabled by setting
  \code{plotLegend} to \code{FALSE}
  
  The \code{drawBorders} argument controls whether borders are drawn around
  the bars in \code{plotDegree}, \code{plotContribution}, and 
  \code{plotSummary}.
}
\subsection{Customising the color palette:}{
  \code{plotCorrelation} and \code{plotCorrelationLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the correlation. They expect the first element of the 
  \code{palette} vector to be the color used for correlation values of -1,
  and the last element of the \code{palette} vector to be the color used for 
  correlation values of 1.
  
  \code{plotNetwork} and \code{plotNetworkLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the edge weights. They expect the first element of the 
  \code{palette} vector to be the color used for edge weights of 0,
  and the last element of the \code{palette} vector to be the color used for 
  correlation values of 1.
  
  \code{plotDegree} expects \code{palette} to be a single color, a 
  vector of colors, one for each node, or a vector of colors to be repeated.
  
  \code{plotContribution} expects \code{palette} to be a vector 
  containing two colors, the first to be used for nodes with negative node
  contribution values, and the second to be used for nodes with positive node
  contribution values. 
  
  \code{plotData} and \code{plotDataLegend} expect the \code{palette}
  argument to be a vector of colors to interpolate over when plotting the
  'data.' In order to accomodate data matrices with different ranges,
  these functions expect the palette to be a diverging set of colors with a
  centre value of 0 (e.g. white). The colors drawn are balanced around 0: 
  i.e. positive and negative values of data will have the same intensity on a 
  diverging color palette regardless of the actual range of the data.
  
  \code{plotSummary} expects \code{palette} to be a vector 
  containing two colors, the first to be used for nodes with a negative 
  module summary measurement, and the second to be used for genes with a 
  positive module summary measurment, regardless of whether the data matrix
  is centred around 0.
}
}
\examples{
\dontrun{
# load in example data, correlation, and network matrices for a discovery and test dataset:
data("NetRep")

# Convert them to the 'bigMatrix' format:
discovery_data <- as.bigMatrix(discovery_data)
discovery_correlation <- as.bigMatrix(discovery_correlation)
discovery_network <- as.bigMatrix(discovery_network)
test_data <- as.bigMatrix(test_data)
test_correlation <- as.bigMatrix(test_correlation)
test_network <- as.bigMatrix(test_network)

# Set up input lists for each input matrix type across datasets:
data_list <- list(discovery=discovery_data, test=test_data)
correlation_list <- list(discovery=discovery_correlation, test=test_correlation)
network_list <- list(discovery=discovery_network, test=test_network)
labels_list <- list(discovery=module_labels)

# Plot the data for module 1, 2 and 4 in the discovery dataset
plotData(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4)
)

# Symmetric = TRUE gives a traditional heatmap for the correlation structure
# and weighted network
plotCorrelation(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), symmetric=TRUE
)

# While the default is to render only one half of the (symmetric) matrix
plotNetwork(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4)
)

# Plot the degree of nodes in each module in the test dataset, but show them
# in the same order as the discovery dataset to compare how node degree 
# changes
plotDegree(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), discovery="discovery",
  test="test"
)

# Alternatively nodes can be ordered on the plot by degree in the test dataset
plotDegree(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), discovery="discovery",
  test="test", orderNodesBy="test"
)

# Or by averaging the degree across datasets for a more robust ordering  
plotDegree(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), discovery="discovery",
  test="test", orderNodesBy=c("discovery", "test")
)

# Arbitrary subsets can be plotted:
plotContribution(
  data=data_list[[1]][, 1:10], correlation=correlation_list[[1]][1:10, 1:10], 
  network=network_list[[1]][1:10, 1:10], orderNodesBy=NA
)

# Plot the module summary vectors for multiple modules:
plotSummary(
  data=data_list, correlation=correlation_list, network=network_list, 
  moduleAssignments=labels_list, modules=c(1, 2, 4), discovery="discovery",
  test="test", orderSamplesBy="test"
)
}

}
\seealso{
\code{\link{plotModule}} for a combined plot showing all topological 
properties for a network module.
}

