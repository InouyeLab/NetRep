% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot-topology.R
\name{plotTopology}
\alias{plotContribution}
\alias{plotCorrelation}
\alias{plotCorrelationLegend}
\alias{plotData}
\alias{plotDataLegend}
\alias{plotDegree}
\alias{plotNetwork}
\alias{plotNetworkLegend}
\alias{plotSummary}
\alias{plotTopology}
\title{Plot a topological feature of network module}
\usage{
plotData(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = 1, test = 1,
  nCores = 1, verbose = TRUE, orderSamplesBy = "test",
  orderNodesBy = "discovery", orderModules = TRUE, plotNodeNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames, main = "",
  palette = data.palette(), border.width = 2, plotLegend = TRUE,
  legend.main = "Data", gaxt.line = -0.5, saxt.line = -0.5,
  maxt.line = 3, legend.position = 0.15, legend.tick.size = 0.03,
  laxt.line = 3, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCorrelation(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = 1, test = 1,
  nCores = 1, verbose = TRUE, orderNodesBy = "discovery",
  symmetric = FALSE, orderModules = TRUE, plotNodeNames = TRUE,
  plotModuleNames, main = "", palette = correlation.palette(),
  border.width = 2, plotLegend = TRUE, legend.main = "Correlation",
  gaxt.line = -0.5, maxt.line = 3, legend.position, legend.tick.size,
  laxt.line, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotNetwork(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = 1, test = 1,
  nCores = 1, verbose = TRUE, orderNodesBy = "discovery",
  symmetric = FALSE, orderModules = TRUE, plotNodeNames = TRUE,
  plotModuleNames, main = "", palette = network.palette(),
  border.width = 2, plotLegend = TRUE, legend.main = "Edge weight",
  gaxt.line = -0.5, maxt.line = 3, legend.position, legend.tick.size,
  laxt.line, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotContribution(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = 1, test = 1,
  nCores = 1, verbose = TRUE, orderSamplesBy = "test",
  orderNodesBy = "discovery", orderModules = TRUE, plotNodeNames = TRUE,
  plotModuleNames, main = "", border.width = 2, palette = c("#313695",
  "#a50026"), drawBorders = FALSE, gaxt.line = -0.5, maxt.line = 3,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotDegree(data, correlation, network, moduleAssignments = NULL,
  modules = NULL, backgroundLabel = "0", discovery = 1, test = 1,
  nCores = 1, verbose = TRUE, orderNodesBy = "discovery",
  orderModules = TRUE, plotNodeNames = TRUE, plotModuleNames, main = "",
  palette = "#feb24c", border.width = 2, drawBorders = FALSE,
  gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)

plotSummary(data, correlation, network, moduleAssignments, modules,
  discovery = 1, test = 1, orderSamplesBy = "test",
  orderNodesBy = "discovery", orderModules, plotSampleNames = TRUE,
  plotModuleNames, main = "", palette = c("#762a83", "#1b7837"),
  border.width = 2, drawBorders = FALSE, saxt.line = -0.5,
  maxt.line = 0, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotDataLegend(data, correlation, network, moduleAssignments, modules,
  discovery = 1, test = 1, palette = data.palette(), border.width = 2,
  horizontal = TRUE, legend.main = "data", legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCorrelationLegend(palette = correlation.palette(), border.width = 2,
  horizontal = TRUE, legend.main = "correlation", legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotNetworkLegend(palette = network.palette(), border.width = 2,
  horizontal = TRUE, legend.main = "network", legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)
}
\arguments{
\item{data}{a list of numeric matrices. Each entry of the list corresponds to
a dataset and contains the data used to infer the interaction network
between variables (e.g. genes). Expects matrix columns to correspond to
variables and matrix rows to correspond to samples.}

\item{correlation}{a list of matrices. Each entry of the list corresponds to a 
dataset and contains an \eqn{n * n} matrix of the correlation between 
each pair of variables in the dataset.}

\item{network}{a list of matrices. Each entry of the list corresponds to a 
dataset and contains an \eqn{n * n} matrix of the network edge weights 
between each pair of variables in the dataset.}

\item{moduleAssignments}{a vector containing the module each variable belongs
to in the discovery dataset. If there are multiple discovery datasets 
then this argument should be a list of such vectors.}

\item{modules}{a list of vectors, one for each \code{discovery} dataset, 
of modules to perform the analysis on. The default is to analyse all modules
with the exception of those specified in \code{backgroundLabel}.}

\item{backgroundLabel}{a single label that nodes that do not belong to any
module are assigned. The default is "0".}

\item{discovery}{a vector of names or indices denoting the discovery dataset(s).}

\item{test}{a list of vectors of names or indices denoting the test datasets
for each \code{discovery} dataset. Alternatively can be provided as vector
if the test datasets are the same for all 'discovery' datasets (e.g. for 
performing a pairwise comparison).}

\item{nCores}{number of cores to parallelise the calculation of network 
properties over. Ignored if the user has already registered a parallel 
backend.}

\item{verbose}{logical; should progress be reported? Default is \code{TRUE}.}

\item{orderSamplesBy}{one of "discovery", "test" or "none". Controls how 
samples are ordered on the plot (see details).}

\item{orderNodesBy}{one of "discovery", "test" or "none". Controls how nodes
are ordered on the plot (see details).}

\item{orderModules}{logical; if \code{TRUE} modules ordered by clustering 
their summary vectors. If \code{FALSE} modules are returned in the order
provided.}

\item{plotNodeNames}{logical; controls whether the node names are 
rendered on the bottom axis.}

\item{plotSampleNames}{logical; controls whether the sample names are 
rendered on the left axis.}

\item{plotModuleNames}{logical; controls whether module names are rendered.
The default is for module names to be rendered when multiple \code{modules} 
are drawn.}

\item{main}{title for each plot.}

\item{palette}{a vector of colors to use for each plot (see details).}

\item{border.width}{line width for borders.}

\item{plotLegend}{logical; controls whether a legend is drawn when using
\code{plotCorrelation}, \code{plotNetwork}, or \code{plotData}.}

\item{legend.main}{title for the legend.}

\item{gaxt.line}{the number of lines into the bottom margin at which the node
names will be drawn.}

\item{saxt.line}{the number of lines into the left margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the bottom margin at which the 
module names will be drawn.}

\item{legend.position}{the distance from the plot to start the legend, as a
proportion of the plot width.}

\item{legend.tick.size}{size of the ticks on each axis legend relative to the
size of the correlation, edge weights, and data matrix heatmaps.}

\item{laxt.line}{the distance from the legend to render the legend axis 
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the node and sample names.}

\item{cex.lab}{relative size of the module names and legend titles.}

\item{cex.main}{relative size of the plot titles.}

\item{symmetric}{logical; controls whether the correlation and network 
heatmaps are drawn as symmetric (square) heatmaps or asymettric triangle 
heatmaps. If symmetric, then the node and module names will also be rendered
on the left axis.}

\item{drawBorders}{logical; if \code{TRUE}, borders are drawn around the bars
in \code{plotContribution}, \code{plotDegree}, and
\code{plotSummary}.}

\item{horizontal}{logical; controls whether the legend is rendered 
horizontally or vertically when using \code{plotDataLegend},
\code{plotCorrelationLegend} or \code{plotNetworkLegend}.}
}
\description{
Functions for plotting the topology of a network module.

\code{plotData}: Plot a heatmap of the data matrix for one or more
network modules.

\code{plotCorrelation}: Plot a heatmap of the correlation structure for one 
or more network modules.

\code{plotNetwork}: Plot a heatmap of the edge weights for one or more
network modules.

\code{plotContribution}: Plot a bar chart of the module membership for
one or more network modules.

\code{plotDegree:} Plot a bar chart of the normalised intramodular 
connectivity (see details) for one or more network modules.

\code{plotSummary}: Plot bar charts of the module summary vectors of 
one or more network modules.

\code{plotDataLegend}: Plot a legend for the data matrix heatmap
for one or more network modules.

\code{plotCorrelationLegend}: Plot a legend for the correlation structure 
heatmap.

\code{plotNetworkLegend}: Plot a legend for the network edge weights heatmap.
}
\details{
\subsection{Input data structure:}{
  This function allows for input data formatted in a number of ways. Where 
  there are multiple datasets of interest (e.g. multiple tissues, locations, 
  or a discovery dataset and an independent test dataset) the arguments 
  \code{data}, \code{correlation}, and \code{network} should be
  \code{\link[=list]{lists}} where each element contains the matrix data for 
  each respective dataset. Alternatively, if only one dataset is of interest, 
  the \code{data}, \code{correlation}, and \code{network} arguments
  will also each accept a 'matrix' object.
  
  Similarly, the \code{moduleAssignments} argument expects a list of named
  vectors, which denote the module each variable belongs to in the discovery
  dataset. If module discovery has only been performed in one dataset, then 
  the \code{moduleAssignments} argument will also accept a named vector.
  
  The \code{discovery} arguments specifies which dataset the \code{modules} 
  of interest were discovered in, and the \code{test} argument specifies 
  which dataset to calculate the network properties in. These arguments are
  ignored if data is provided for only one dataset.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link[=bigMatrix-class]{bigMatrix}} 
  data, regular 'matrix' objects are also accepted. In this case, the 
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on 
  disk, which can take a long time for large datasets. It is strongly 
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link[=plotModule]{plotting} 
  \link[=plotTopology]{functions}, \link[=nodeOrder]{node} and 
  \link[=sampleOrder]{sample} ordering functions also expect 'bigMatrix'
  objects. Further, 'bigMatrix' objects have a number of benefits, including 
  instantaneous load time from any future R session, and parallel access from
  mutliple independent R sessions. Methods are provided for 
  \link[=bigMatrix-get]{converting to, loading in}, and 
  \link[=bigMatrix-out]{writing out} 'bigMatrix' objects.
}
\subsection{Node, sample, and module ordering:}{
  By default, nodes are ordered in decreasing order of \emph{weighted degree}
  in the \code{discovery} dataset (see \code{\link{nodeOrder}}). 
  This facilitates the visual comparison of modules across datasets, as the 
  node ordering will be preserved. Missing nodes are colored in grey. If
  \code{orderNodesBy} is "test" nodes will instead be ordered by 
  weighted degree in the \code{test} dataset. If "none" nodes are 
  drawn in the order they are provided in the drawn dataset.
  
  When multiple modules are specified, modules are ordered by the similarity
  of their summary vectors in the drawn dataset. To disable this behaviour, 
  set \code{orderModules} to \code{FALSE}.
  
  Sample ordering only applies to \code{plotData} and 
  \code{plotModuleSummary}. By default, samples are ordered in descending
  order of the module summary vector in the drawn dataset for the left-most 
  module appearing on the plot (see \code{\link{sampleOrder}}.
}
\subsection{Normalised degree:}{
  The weighted degree is normalised by the maximum connectivity in
  any given module when rendered on the bar plot. This facilitates visual 
  comparison of multiple modules with differing sizes or densities.
}
\subsection{Customising plot layout:}{
  Although reasonable default values for most parameters have been provided,
  the rendering of axes and titles may need adjusting depending on the size
  of the plot window. The parameters \code{gaxt.line}, \code{saxt.line}, 
  \code{maxt.line}, and \code{laxt.line} control the distance from each plot
  window that the node labels, sample labels, module labels, and legend 
  labels are rendered. 
  
  \code{legend.tick.size} controls the length of the 
  axis ticks on each of the legends relative to the correlation, network,
  and data plot windows. 
  
  \code{legend.position} controls the horizontal offset of the legend 
  relative to the plot. For the triangle heatmaps, (\code{symmetric=FALSE} in
  \code{plotCorrelation} and \code{plotNetwork}) this controls how far 
  left of the plot the legend starts as a proportion of the plot width. For
  the square heatmaps (\code{plotData}, and \code{symmetric=TRUE} in
  \code{plotCorrelation} and \code{plotNetwork}) this controls how far 
  right of the plot the legend starts as a proportion of the plot width.
  
  \code{cex.main} controls the relative text size of the plot title
  (specified by the \code{main} argument). \code{cex.axis} controls the
  relative text size of the node and sample labels. \code{cex.lab} controls
  the relative text size of the bar plot axis labels, module labels, and the
  legend titles.
  
  The rendering of node, sample, and module names can be disabled by setting
  \code{plotNodeNames}, \code{plotSampleNames}, and \code{plotModuleNames} to
  \code{FALSE}, and the rendering of the legend can be disabled by setting
  \code{plotLegend} to \code{FALSE}
  
  The \code{drawBorders} argument controls whether borders are drawn around
  the bars in \code{plotDegree}, \code{plotContribution}, and 
  \code{plotSummary}.
}
\subsection{Customising the color palette:}{
  \code{plotCorrelation} and \code{plotCorrelationLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the correlation. They expect the first element of the 
  \code{palette} vector to be the color used for correlation values of -1,
  and the last element of the \code{palette} vector to be the color used for 
  correlation values of 1.
  
  \code{plotNetwork} and \code{plotNetworkLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the edge weights. They expect the first element of the 
  \code{palette} vector to be the color used for edge weights of 0,
  and the last element of the \code{palette} vector to be the color used for 
  correlation values of 1.
  
  \code{plotDegree} expects \code{palette} to be a single color, a 
  vector of colors, one for each node, or a vector of colors to be repeated.
  
  \code{plotContribution} expects \code{palette} to be a vector 
  containing two colors, the first to be used for nodes with negative node
  contribution values, and the second to be used for nodes with positive node
  contribution values. 
  
  \code{plotData} and \code{plotDataLegend} expect the \code{palette}
  argument to be a vector of colors to interpolate over when plotting the
  'data.' In order to accomodate data matrices with different ranges,
  these functions expect the palette to be a diverging set of colors with a
  centre value of 0 (e.g. white). The colors drawn are balanced around 0: 
  i.e. positive and negative values of data will have the same intensity on a 
  diverging color palette regardless of the actual range of the data.
  
  \code{plotSummary} expects \code{palette} to be a vector 
  containing two colors, the first to be used for nodes with a negative 
  module summary measurement, and the second to be used for genes with a 
  positive module summary measurment, regardless of whether the data matrix
  is centred around 0.
}
}
\examples{
\dontrun{
## Create some example data
geA <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geA) <- paste0("Gene_", 1:100)
rownames(geA) <- paste0("CohortA_", 1:50)
coexpA <- cor(geA) # correlation
adjA <- abs(coexpA)^5 # network
moduleAssignments <- sample(1:7, size=100, replace=TRUE)
names(moduleAssignments) <- paste0("Gene_", 1:100)

# Create bigMatrix objects for each matrix.
geA <- as.bigMatrix(geA, "geA_bm")
coexpA <- as.bigMatrix(coexpA, "coexpA_bm")
adjA <- as.bigMatrix(adjA, "adjA_bm")

## Example 1: Plot Module 2 in cohort A.
plotData(geA, coexpA, adjA, moduleAssignments, modules="2")
plotCorrelation(geA, coexpA, adjA, moduleAssignments, modules="2")
# alternatively as a square heatmap
plotCorrelation(
 geA, coexpA, adjA, moduleAssignments, modules="2", symmetric=TRUE
)
plotNetwork(geA, coexpA, adjA, moduleAssignments, modules="2")
plotDegree(geA, coexpA, adjA, moduleAssignments, modules="2")
plotContribution(geA, coexpA, adjA, moduleAssignments, modules="2")
plotSummary(geA, coexpA, adjA, moduleAssignments, modules="2")

## Example 2: Plot an arbitrary set of genes in cohort A
plotData(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotCorrelation(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
# alternatively as a square heatmap
plotCorrelation(
 geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10], symmetric=TRUE
)
plotNetwork(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotDegree(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotContribution(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotSummary(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])

## Example 3: Plot the topology of two adipose tissue modules in the liver
## tissue data 

geAdipose <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geAdipose) <- paste0("Gene_", 1:100)
rownames(geAdipose) <- paste0("Sample_", 1:50)
coexpAdipose <- cor(geAdipose) # correlation
adjAdipose <- abs(coexpAdipose)^5 # network
adiposeModules <- sample(0:7, size=100, replace=TRUE)
names(adiposeModules) <- paste0("Gene_", 1:100)

geLiver <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geLiver) <- paste0("Gene_", 1:100)
rownames(geLiver) <- paste0("Sample_", 1:50)
coexpLiver <- cor(geLiver) # correlation
adjLiver <- abs(coexpLiver)^6 # network
liverModules <- sample(0:12, size=100, replace=TRUE)
names(liverModules) <- paste0("Gene_", 1:100)

geHeart <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geHeart) <- paste0("Gene_", 1:100)
rownames(geHeart) <- paste0("Sample_", 1:50)
coexpHeart <- cor(geHeart) # correlation
adjHeart <- abs(coexpHeart)^4 # network
heartModules <- sample(0:5, size=100, replace=TRUE)
names(heartModules) <- paste0("Gene_", 1:100)

# Store each input type as a list, where each element corresponds
# to one of the datasets
geneExpression <- list(
  adipose=as.bigMatrix(geAdipose, "geAdipose_bm"),
  liver=as.bigMatrix(geLiver, "geLiver_bm"),  
  heart=as.bigMatrix(geHeart, "geHeart_bm") 
)
correlation <- list(
  adipose=as.bigMatrix(coexpAdipose, "coexpAdipose_bm"),
  liver=as.bigMatrix(coexpLiver, "coexpLiver_bm"),  
  heart=as.bigMatrix(coexpHeart, "coexpHeart_bm") 
)
network <- list(
  adipose=as.bigMatrix(adjAdipose, "adjAdipose_bm"),
  liver=as.bigMatrix(adjLiver, "adjLiver_bm"),  
  heart=as.bigMatrix(adjHeart, "adjHeart_bm") 
)
moduleAssignments <- list(
  adipose=adiposeModules, liver=liverModules, heart=heartModules
)

# Show the plot
plotData(
 geneExpression, correlation, network, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotCorrelation(
 geneExpression, correlation, network, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
# alternatively as a square heatmap
plotCorrelation(
 geneExpression, correlation, network, moduleAssignments, 
 modules=c("3", "7"), discovery="adipose", test="liver", symmetric=TRUE
)
plotNetwork(
 geneExpression, correlation, network, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotDegree(
 geneExpression, correlation, network, moduleAssignments, 
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotContribution(
 geneExpression, correlation, network, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotSummary(
 geneExpression, correlation, network, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)

# clean up bigMatrix files from examples
unlink("*_bm*")
}

}
\seealso{
\code{\link{plotModule}} for a combined plot showing all topological 
properties for a network module.
}

