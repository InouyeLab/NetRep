% Generated by roxygen2 (4.0.2): do not edit by hand
\name{geneOrder}
\alias{geneOrder}
\title{Order genes and modules within a network.}
\usage{
geneOrder(geneExpression = NULL, coexpression, adjacency, moduleAssignments,
  modules, discovery = 1, test = 1, na.rm = FALSE, orderModules = TRUE,
  simplify = TRUE)
}
\arguments{
\item{geneExpression}{optional; \code{NULL} or a list of
\code{\link[=bigMatrix-class]{bigMatrix}} objects, each containing the gene
expression data for a datset of interest (see details). Columns are
expected to be genes, rows samples.}

\item{coexpression}{a list of 'bigMatrix' objects, each containing the gene
coexpression for a dataset of interest (see details).}

\item{adjacency}{a list of 'bigMatrix' objects, each containing the gene
adjacencies for a dataset of interest (see details).}

\item{moduleAssignments}{a list of named vectors assigning genes to modules
in each dataset of interest (see details).}

\item{modules}{a vector of modules to apply the function to (see details).}

\item{discovery}{name or index denoting which dataset the module of interest
was discovered in (see details).}

\item{test}{name or index denoting which dataset to apply the function to
(see details).}

\item{na.rm}{logical; If \code{TRUE}, genes present in the \code{discovery}
dataset but missing from the test dataset are excluded. If \code{FALSE},
missing genes are put last in the ordering.}

\item{orderModules}{logical; if \code{TRUE} modules ordered by the clustering
of their summary expression profile. If \code{FALSE} modules are returned
in the order provided.}

\item{simplify}{logical; if \code{FALSE} the returned data structure will be
  a list of vectors of ordered genes, one list element for each module. If
  \code{TRUE}, the returned data structure will be a single vector of
  ordered genes.}
}
\value{
A vector of gene names in descending order of intramodular connectivity for
 each module.
}
\description{
Order genes in descending order of intramodular connectivity within each
module, and order modules by the similarity of their summary expression
profiles. Intramodular connectivity is strongly correlated with biological
importance within a given module \emph{(1)}.
}
\details{
\subsection{Input data structure:}{
  This function allows for input data formatted in a number of ways. Where
  there are multiple datasets of interest (e.g. multiple tissues, or a
  discovery dataset and an independent test dataset) the arguments
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} should be
  \code{\link[=list]{lists}} where each element contains the matrix data for
  each respective dataset. This matrix data should be stored as a 'bigMatrix'
  object (see \link[=bigMatrix-get]{converting matrix data to 'bigMatrix'
  data}). Alternatively, if only one dataset is of interest, the
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} arguments
  will also each accept a single 'bigMatrix' object.

  Similarly, the \code{moduleAssignments} argument expects a list of named
  vectors assigning genes to modules in each dataset module discovery has
  been performed in. Alternatively, a named vector is also accepted for cases
  where module discovery has been performed in only one dataset.
  If \code{moduleAssignments} is not specified, then the network properties
  will be calculated for all genes in the specified dataset(s).

  The \code{discovery} arguments specifies which dataset the \code{modules}
  of interest were discovered in, and the \code{test} argument specifies
  which dataset to calculate the network properties from. These arguments are
  ignored if data is provided for only one dataset. Otherwise, the function
  defaults to calculating the network properties for \code{modules} from the
  first dataset specified in the list structure of \code{geneExpression},
  \code{coexpression}, and \code{adjacency}, in that same dataset.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link[=bigMatrix-class]{bigMatrix}}
  data, regular 'matrix' objects are also accepted. In this case, the
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on
  disk, which can take a long time for large datasets. It is strongly
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link{networkProperties} function,
  \link[=plotModule]{plotting} \link[=plotTopology]{functions}, and
  \link[=sampleOrder]{sample} ordering also expect 'bigMatrix' objects.
  Further, 'bigMatrix' objects have a number of benefits, including
  instantaneous load time from any future R session, and parallel access from
  mutliple independent R sessions. Methods are provided for
  \link[=bigMatrix-get]{converting to, loading in}, and
  \link[=bigMatrix-out]{writing out} 'bigMatrix' objects.
}
}
\examples{
\dontrun{
## Create some example data
geA <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geA) <- paste0("Gene_", 1:100)
rownames(geA) <- paste0("CohortA_", 1:50)
coexpA <- cor(geA) # coexpression
adjA <- abs(coexpA)^5 # adjacency
moduleAssignments <- sample(1:7, size=100, replace=TRUE)
names(moduleAssignments) <- paste0("Gene_", 1:100)

# Create bigMatrix objects for each matrix.
geA <- as.bigMatrix(geA, "geA_bm")
coexpA <- as.bigMatrix(coexpA, "coexpA_bm")
adjA <- as.bigMatrix(adjA, "adjA_bm")

## Example 1: get the ordering of samples for a single module
geneOrder(
  geA, coexpA, adjA, moduleAssignments, modules="2"
)

## Example 2: get the order of genes of an arbitrary subset
## (the first 10 genes)
geneOrder(
 geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10]
)

## Example 3: get the ordering of genes for two adipose
## tissue modules in the liver tissue of the same samples

geAdipose <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geAdipose) <- paste0("Gene_", 1:100)
rownames(geAdipose) <- paste0("Sample_", 1:50)
coexpAdipose <- cor(geAdipose) # coexpression
adjAdipose <- abs(coexpAdipose)^5 # adjacency
adiposeModules <- sample(0:7, size=100, replace=TRUE)
names(adiposeModules) <- paste0("Gene_", 1:100)

geLiver <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geLiver) <- paste0("Gene_", 1:100)
rownames(geLiver) <- paste0("Sample_", 1:50)
coexpLiver <- cor(geLiver) # coexpression
adjLiver <- abs(coexpLiver)^6 # adjacency
liverModules <- sample(0:12, size=100, replace=TRUE)
names(liverModules) <- paste0("Gene_", 1:100)

geHeart <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geHeart) <- paste0("Gene_", 1:100)
rownames(geHeart) <- paste0("Sample_", 1:50)
coexpHeart <- cor(geHeart) # coexpression
adjHeart <- abs(coexpHeart)^4 # adjacency
heartModules <- sample(0:5, size=100, replace=TRUE)
names(heartModules) <- paste0("Gene_", 1:100)

# Store each input type as a list, where each element corresponds
# to one of the datasets
geneExpression <- list(
  adipose=as.bigMatrix(geAdipose, "geAdipose_bm"),
  liver=as.bigMatrix(geLiver, "geLiver_bm"),
  heart=as.bigMatrix(geHeart, "geHeart_bm")
)
coexpression <- list(
  adipose=as.bigMatrix(coexpAdipose, "coexpAdipose_bm"),
  liver=as.bigMatrix(coexpLiver, "coexpLiver_bm"),
  heart=as.bigMatrix(coexpHeart, "coexpHeart_bm")
)
adjacency <- list(
  adipose=as.bigMatrix(adjAdipose, "adjAdipose_bm"),
  liver=as.bigMatrix(adjLiver, "adjLiver_bm"),
  heart=as.bigMatrix(adjHeart, "adjHeart_bm")
)
moduleAssignments <- list(
  adipose=adiposeModules, liver=liverModules, heart=heartModules
)

# Get the order of genes in the liver tissue for modules
# 3 and 7, which were discovered in the adipose tissue.
geneOrder(
  geneExpression, coexpression, adjacency, moduleAssignments,
  modules=c("3", "7"), discovery="adipose", test="liver"
)

# clean up bigMatrix files from examples
unlink("*_bm*")
}
}
\references{
\enumerate{
   \item{
     Langfelder, P., Mischel, P. S. & Horvath, S. \emph{When is hub gene
     selection better than standard meta-analysis?} PLoS One \strong{8},
     e61505 (2013).
   }
}
}

