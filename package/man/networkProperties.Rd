% Generated by roxygen2 (4.0.2): do not edit by hand
\name{networkProperties}
\alias{networkProperties}
\title{Calculate the topological properties for a network module}
\usage{
networkProperties(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1, simplify = TRUE)
}
\arguments{
\item{geneExpression}{optional; \code{NULL} or a list of
\code{\link[=bigMatrix-class]{bigMatrix}} objects, each containing the gene
expression data for a datset of interest (see details). Columns are
expected to be genes, rows samples.}

\item{coexpression}{a list of 'bigMatrix' objects, each containing the gene
coexpression for a dataset of interest (see details).}

\item{adjacency}{a list of 'bigMatrix' objects, each containing the gene
adjacencies for a dataset of interest (see details).}

\item{moduleAssignments}{a list of named vectors assigning genes to modules
for each datast of interest (see details).}

\item{modules}{a vector of modules to apply the function to (see details).}

\item{discovery}{name or index denoting which dataset the module of interest
was discovered in (see details).}

\item{test}{name or index denoting which dataset to apply the function to
(see details).}

\item{simplify}{logical; if \code{TRUE} the output data structure is
  simplified if only one module is specified.}
}
\value{
A list of network properties for each module of interests containing:
 \itemize{
   \item{connectivity:}{
     The intramodular connectivity for each gene in the module
   }
   \item{density:}{
     The mean adjacency for genes in the module.
   }
 }
 If gene expression data is provided for the \code{test} dataset then the
 following are also returned:
 \itemize{
   \item{summaryExpression:}{
     The summary expression profile (first eigenvector of the gene
     expression from a principal component analysis) for the module.
   }
   \item{moduleMembership:}{
     The correlation between each gene and the summary expression profile.
   }
   \item{propVarExpl:}{
     The proportion of variance explained in the module's gene expression by
     its summary expression profile.
   }
 }
}
\description{
Calculates the network properties used to assess module preservation for one
or more modules in a user specified dataset.
}
\details{
\subsection{Input data structure:}{
  This function allows for input data formatted in a number of ways. Where
  there are multiple datasets of interest (e.g. multiple tissues, or a
  discovery dataset and an independent test dataset) the arguments
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} should be
  \code{\link[=list]{lists}} where each element contains the matrix data for
  each respective dataset. This matrix data should be stored as a 'bigMatrix'
  object (see \link[=bigMatrix-get]{converting matrix data to 'bigMatrix'
  data}). Alternatively, if only one dataset is of interest, the
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} arguments
  will also each accept a single 'bigMatrix' object.

  Similarly, the \code{moduleAssignments} argument expects a list of named
  vectors, which contain the the module assignments for each gene in the
  respective dataset. List elements corresponding to datasets where module
  discovery has not been performed should contain \code{NULL}. These
  \code{NULL} elements can be excluded if the datasets are named throughout
  the function arguments, i.e. where the \code{\link{names}} of
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} correspond
  to the names of each dataset of interest, the names of the \code{discovery}
  dataset can be used to look up the respective module assignments in the
  \code{moduleAssignments} list. If module discovery has only been performed
  in one dataset, then the list structure may be omitted. In this case, the
  function assumes that the discovery dataset corresponds to the first list
  element of each of the \code{geneExpression}, \code{coexpression},
  \code{adjacency} arguments.

  The \code{discovery} arguments specifies which dataset the \code{modules}
  of interest were discovered in, and the \code{test} argument specifies
  which dataset to calculate the network properties from. These arguments are
  ignored if data is provided for only one dataset. Otherwise, the function
  defaults to calculating the network properties for \code{modules} from the
  first dataset specified in the list structure of \code{geneExpression},
  \code{coexpression}, and \code{adjacency}, in that same dataset.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link[=bigMatrix-class]{bigMatrix}}
  data, regular 'matrix' objects are also accepted. In this case, the
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on
  disk, which can take a long time for large datasets. It is strongly
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link[=plotModule]{plotting}
  \link[=plotTopology]{functions}, \link[=geneOrder]{gene} and
  \link[=sampleOrder]{sample} ordering also expect 'bigMatrix' objects.
  Further, 'bigMatrix' objects have a number of benefits, including
  instantaneous load time from any future R session, and parallel access from
  mutliple independent R sessions. Methods are provided for
  \link[=bigMatrix-get]{converting to, loading in}, and
  \link[=bigMatrix-out]{writing out} 'bigMatrix' objects.
}
}
\examples{
\dontrun{
## Create some example data
geA <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geA) <- paste0("Gene_", 1:100)
rownames(geA) <- paste0("CohortA_", 1:50)
coexpA <- cor(geA) # coexpression
adjA <- abs(coexpA)^5 # adjacency
moduleAssignments <- sample(1:7, size=100, replace=TRUE)
names(moduleAssignments) <- paste0("Gene_", 1:100)

# Create bigMatrix objects for each matrix.
geA <- as.bigMatrix(geA, "geA_bm")
coexpA <- as.bigMatrix(coexpA, "coexpA_bm")
adjA <- as.bigMatrix(adjA, "adjA_bm")

## Example 1: calculate network properties for a single module
networkProperties(
  geA, coexpA, adjA, moduleAssignments, modules="2"
)

## Example 2: calculate the network properties on a user defined
## subset of the first 10 genes.
networkProperties(
 geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10]
)

## Example 3: calculate the network properties of an adipose tissue
## module in the liver tissue of the same samples

geAdipose <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geAdipose) <- paste0("Gene_", 1:100)
rownames(geAdipose) <- paste0("Sample_", 1:50)
coexpAdipose <- cor(geAdipose) # coexpression
adjAdipose <- abs(coexpAdipose)^5 # adjacency
adiposeModules <- sample(0:7, size=100, replace=TRUE)
names(adiposeModules) <- paste0("Gene_", 1:100)

geLiver <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geLiver) <- paste0("Gene_", 1:100)
rownames(geLiver) <- paste0("Sample_", 1:50)
coexpLiver <- cor(geLiver) # coexpression
adjLiver <- abs(coexpLiver)^6 # adjacency
liverModules <- sample(0:12, size=100, replace=TRUE)
names(liverModules) <- paste0("Gene_", 1:100)

geHeart <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geHeart) <- paste0("Gene_", 1:100)
rownames(geHeart) <- paste0("Sample_", 1:50)
coexpHeart <- cor(geHeart) # coexpression
adjHeart <- abs(coexpHeart)^4 # adjacency
heartModules <- sample(0:5, size=100, replace=TRUE)
names(heartModules) <- paste0("Gene_", 1:100)

# Store each input type as a list, where each element corresponds
# to one of the datasets
geneExpression <- list(
  adipose=as.bigMatrix(geAdipose, "geAdipose_bm"),
  liver=as.bigMatrix(geLiver, "geLiver_bm"),
  heart=as.bigMatrix(geHeart, "geHeart_bm")
)
coexpression <- list(
  adipose=as.bigMatrix(coexpAdipose, "coexpAdipose_bm"),
  liver=as.bigMatrix(coexpLiver, "coexpLiver_bm"),
  heart=as.bigMatrix(coexpHeart, "coexpHeart_bm")
)
adjacency <- list(
  adipose=as.bigMatrix(adjAdipose, "adjAdipose_bm"),
  liver=as.bigMatrix(adjLiver, "adjLiver_bm"),
  heart=as.bigMatrix(adjHeart, "adjHeart_bm")
)
moduleAssignments <- list(
  adipose=adiposeModules, liver=liverModules, heart=heartModules
)

# Get the network properties in the liver tissue for modules
# 3 and 7, which were discovered in the adipose tissue.
networkProperties(
  geneExpression, coexpression, adjacency, moduleAssignments,
  modules=c("3", "7"), discovery="adipose", test="liver"
)

# clean up bigMatrix files from examples
unlink("*_bm*")
}
}
\references{
\enumerate{
   \item{
     Langfelder, P., Mischel, P. S. & Horvath, S. \emph{When is hub gene
     selection better than standard meta-analysis?} PLoS One \strong{8},
     e61505 (2013).
   }
}
}

