% Generated by roxygen2 (4.0.2): do not edit by hand
\name{api_inputs}
\alias{api_inputs}
\alias{plotAdjacency}
\alias{plotAdjacencyLegend}
\alias{plotCoexpression}
\alias{plotCoexpressionLegend}
\alias{plotConnectivity}
\alias{plotExpression}
\alias{plotExpressionLegend}
\alias{plotModuleMembership}
\alias{plotSummaryExpression}
\title{Plot a topological feature of network module}
\usage{
plotExpression(geneExpression, coexpression, adjacency, moduleAssignments,
  modules, discovery = 1, test = 1, orderSamplesBy = "test",
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames, main = "Gene expression",
  palette = expression.palette(), plotLegend = TRUE,
  legend.main = "Expression", gaxt.line = -0.5, saxt.line = -0.5,
  maxt.line = 3, legend.position = 0.2, legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCoexpression(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1, symmetric = FALSE,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "Coexpression", palette = coexpression.palette(),
  plotLegend = TRUE, legend.main = "Coexpression", gaxt.line = -0.5,
  maxt.line = 3, legend.position, legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotAdjacency(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1, symmetric = FALSE,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "Adjacency", palette = adjacency.palette(),
  plotLegend = TRUE, legend.main = "Adjacency", gaxt.line = -0.5,
  maxt.line = 3, legend.position, legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotModuleMembership(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "Module Membership", palette = c("#313695",
  "#a50026"), drawBorder = FALSE, gaxt.line = -0.5, maxt.line = 3,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotConnectivity(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderGenesBy = "discovery", orderModules = TRUE, plotGeneNames = TRUE,
  plotModuleNames, main = "Normalised Connectivity", palette = "#feb24c",
  drawBorder = FALSE, gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8,
  cex.lab = 1, cex.main = 1.2)

plotSummaryExpression(geneExpression, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderSamplesBy = "test", orderGenesBy = "discovery", orderModules,
  plotSampleNames = TRUE, plotModuleNames, main = "Summary Expression",
  palette = c("#762a83", "#1b7837"), drawBorder = FALSE)

plotExpressionLegend(geneExpression, coexpression, adjacency, moduleAssignments,
  modules, discovery = 1, test = 1, palette = expression.palette(),
  main = "Expression", horizontal = TRUE)

plotCoexpressionLegend(palette = coexpression.palette(),
  main = "Coexpression", horizontal = TRUE)

plotAdjacencyLegend(palette = adjacency.palette(), main = "Adjacency",
  horizontal = TRUE)
}
\arguments{
\item{geneExpression}{the gene expression matrix for the dataset of interest,
or a list of gene expression matrices, one for each dataset. Columns are
expected to be genes, rows samples. See details for expected input types.}

\item{coexpression}{the coexpression matrix for the dataset of interest, or a
list of coexpression matrices, one for each dataset. See details for
expected input types.}

\item{adjacency}{the adjacency matrix for the dataset of interest, or a
list of adjacency matrices, one for each dataset. See details for
expected input types.}

\item{moduleAssignments}{a vector assigning genes to modules, or a list of
such vectors. See details.}

\item{modules}{a vector of modules to apply the function to. See details.}

\item{discovery}{name or index denoting which dataset the module of
interest was discovered in. See details.}

\item{test}{name or index denoting which dataset to apply the function to.
 See details.}

\item{orderSamplesBy}{one of "discovery", "test", or "none". If
"discovery"samples are ordered by their summary expression profile in the
\code{discovery} dataset (see \code{\link{sampleOrder}}). If "test" samples
are ordered by their summary expression profile in the \code{test} dataset.
If "none" no ordering is applied.}

\item{orderGenesBy}{one of "discovery", "test", or "none". If "discovery"
genes are ordered by intramodular connectivity in the \code{discovery}
dataset. If "test" genes are orderd by intramodular connectivity in the
\code{test} dataset. If "none" no ordering is applied.}

\item{orderModules}{logical; if \code{TRUE} modules ordered by similarity of
their summary expression profiles. If \code{FALSE} modules are rendered in
the order provided. The default is to order by modules if the gene
expression is provided.}

\item{plotGeneNames}{logical; if \code{TRUE}, plot the gene names below the
heatmap.}

\item{plotSampleNames}{logical; if \code{TRUE} the sample names will be
plotted next to the gene expression heatmap and summary expression profile
plots}

\item{plotModuleNames}{logical; if \code{TRUE}, plot the module names below
the heatmap. By default, module names are only plotted if multiple
\code{modules} are provided.}

\item{main}{title for the plot.}

\item{palette}{a vector of colors to interpolate over when plotting the
coexpression. The first element should correspond to the color
used when the coexpression between two genes is equal to -1, and the last
element should correspond to the color used when the coexpression between
two genes is equal to 1}

\item{plotLegend}{logical; if \code{TRUE} legends are drawn for
\code{plotCoexpression}, \code{plotAdjacency}, or \code{plotExpression}.}

\item{legend.main}{title for the plot legend.}

\item{gaxt.line}{the number of lines into the margin at which the gene
names will be drawn.}

\item{saxt.line}{the number of lines into the margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the margin at which the module
names will be drawn.}

\item{legend.position}{the distance from the plot to start the legend, as a
proportion of the plot width.}

\item{legend.tick.size}{size of the ticks on the axis legend.}

\item{laxt.line}{the distance from the legend to render the legend axis
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the gene and sample names.}

\item{cex.lab}{relative size of the module names and legend titles.}

\item{cex.main}{relative size of the plot titles.}

\item{symmetric}{logical; if \code{TRUE} the coexpression will be plotted as
a symmetric heatmap, if \code{FALSE} it will be plotted as a triangular
heatmap.}

\item{drawBorder}{logical; if \code{TRUE}, borders are drawn around the bars
in \code{plotModuleMembership}, \code{plotConnectivity}, or
\code{plotSummaryExpression}.}

\item{horizontal}{logical; if \code{TRUE} the legend is plotted horizontally.}
}
\description{
Functions to plot individual components of a module's network topology.
}
\details{
The matrices containing the \code{geneExpression}, \code{coexpression}, and
 \code{adjacency} should be \code{\link{bigMatrix}} object(s), but the
 function will also work with regular matrices, files containing the matrix
 data, or file paths to the descriptor files for a 'bigMatrix', in which
 case temporary 'bigMatrix' objects will be created. It is advisable to keep
 large matrices stored as 'bigMatrix' objects, as the conversion process
 involves writing out the matrix as binary data to disk. 'bigMatrix' objects
 have the added advantage of having instant load times in new R sessions, and
 can be accessed and used the same way as regular matrices. See
 \code{\link{bigMatrix}} for more details.

 This function can be used in three ways. First, the \code{geneExpression},
 \code{coexpression}, and \code{adjacency} can be provided as lists of
 matrices, where each element corresponds to a dataset of interest. In this
 case, the function will be applied to the \code{test} dataset for the subset
 of genes corresponding to modules discovered in the \code{discovery} dataset.
 By default, the function is applied on dataset 1, on the modules discovered
 in dataset 1. Secondly, the function also accepts single matrices for each,
 simplifying the input for users with only one dataset of interest. Finally,
 \code{modules} and \code{moduleAssignments} may be omitted, in which case
 the function is applied on all genes present in the \code{geneExpression},
 \code{coexpression}, and \code{adjacency}. This may be useful when
 subsetting each matrix by a custom gene set of interest.
}

