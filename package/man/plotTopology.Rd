% Generated by roxygen2 (4.0.2): do not edit by hand
\name{plotTopology}
\alias{plotAdjacency}
\alias{plotAdjacencyLegend}
\alias{plotCoexpression}
\alias{plotCoexpressionLegend}
\alias{plotConnectivity}
\alias{plotExpression}
\alias{plotExpressionLegend}
\alias{plotModuleMembership}
\alias{plotSummaryExpression}
\alias{plotTopology}
\title{Plot a topological feature of network module}
\usage{
plotExpression(geneExpression, coexpression, adjacency, moduleAssignments,
  modules, discovery = 1, test = 1, orderSamplesBy = "test",
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames, main = "",
  palette = expression.palette(), plotLegend = TRUE,
  legend.main = "Expression", gaxt.line = -0.5, saxt.line = -0.5,
  maxt.line = 3, legend.position = 0.15, legend.tick.size = 0.03,
  laxt.line = 3, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCoexpression(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1, symmetric = FALSE,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "", palette = coexpression.palette(),
  plotLegend = TRUE, legend.main = "Coexpression", gaxt.line = -0.5,
  maxt.line = 3, legend.position, legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotAdjacency(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1, symmetric = FALSE,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "", palette = adjacency.palette(),
  plotLegend = TRUE, legend.main = "Adjacency", gaxt.line = -0.5,
  maxt.line = 3, legend.position, legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotModuleMembership(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotModuleNames, main = "", palette = c("#313695", "#a50026"),
  drawBorders = FALSE, gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8,
  cex.lab = 1, cex.main = 1.2)

plotConnectivity(geneExpression = NULL, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderGenesBy = "discovery", orderModules = TRUE, plotGeneNames = TRUE,
  plotModuleNames, main = "", palette = "#feb24c", drawBorders = FALSE,
  gaxt.line = -0.5, maxt.line = 3, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)

plotSummaryExpression(geneExpression, coexpression, adjacency,
  moduleAssignments, modules, discovery = 1, test = 1,
  orderSamplesBy = "test", orderGenesBy = "discovery", orderModules,
  plotSampleNames = TRUE, plotModuleNames, main = "",
  palette = c("#762a83", "#1b7837"), drawBorders = FALSE,
  saxt.line = -0.5, maxt.line = 0, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)

plotExpressionLegend(geneExpression, coexpression, adjacency, moduleAssignments,
  modules, discovery = 1, test = 1, palette = expression.palette(),
  horizontal = TRUE, legend.main = "Expression", legend.tick.size = 0.03,
  laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotCoexpressionLegend(palette = coexpression.palette(), horizontal = TRUE,
  legend.main = "Coexpression", legend.tick.size = 0.03, laxt.line = 2.5,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)

plotAdjacencyLegend(palette = adjacency.palette(), horizontal = TRUE,
  legend.main = "Adjacency", legend.tick.size = 0.03, laxt.line = 2.5,
  cex.axis = 0.8, cex.lab = 1, cex.main = 1.2)
}
\arguments{
\item{geneExpression}{optional; a list of
\code{\link[=bigMatrix-class]{bigMatrix}} objects, each containing the gene
expression data for a datset of interest (see details). Columns are
expected to be genes, rows samples. If not provided, the expression,
module membership, and summary expression will not be plotted.}

\item{coexpression}{a list of 'bigMatrix' objects, each containing the gene
coexpression for a dataset of interest (see details).}

\item{adjacency}{a list of 'bigMatrix' objects, each containing the gene
adjacencies for a dataset of interest (see details).}

\item{moduleAssignments}{a list of named vectors assigning genes to modules
in each dataset of interest (see details).}

\item{modules}{a vector of modules to apply the function to (see details).}

\item{discovery}{name or index denoting which dataset the module of interest
was discovered in (see details).}

\item{test}{name or index denoting which dataset to apply the function to
(see details).}

\item{orderSamplesBy}{one of "discovery", "test", or "none" indicating which
dataset the function should use to order the samples (see details).}

\item{orderGenesBy}{one of "discovery", "test", or "none" indicating which
dataset the function should use to order the genes (see details).}

\item{orderModules}{logical; if \code{TRUE} modules will be ordered by the
similarity of their summary expression profiles (see details). The default
is \code{TRUE} if gene expression for the \code{test} dataset is provided.}

\item{plotGeneNames}{logical; controls whether the gene names are
rendered on the bottom axis when using \code{plotExpression},
\code{plotCoxpression}, \code{plotAdjacency}, \code{plotConnectivity},
or \code{plotModuleMembership}.}

\item{plotSampleNames}{logical; controls whether the sample names are
rendered on the left axis when using \code{plotSummaryExpression} or
\code{plotExpression}.}

\item{plotModuleNames}{logical; controls whether module names are rendered
above the bar charts when using \code{plotSummaryExpression}, or on the
bottom axis when using \code{plotExpression}, \code{plotCoexpression},
\code{plotAdjacency}, \code{plotConnectivity}, or
\code{plotModuleMembership}. By default, module names are only rendered
when multiple \code{modules} are specified.}

\item{main}{title for each plot.}

\item{palette}{a vector of colors to use for each plot (see details).}

\item{plotLegend}{logical; controls whether a legend is drawn when using
\code{plotCoexpression}, \code{plotAdjacency}, or \code{plotExpression}.}

\item{legend.main}{title for the legend.}

\item{gaxt.line}{the number of lines into the bottom margin at which the gene
names will be drawn.}

\item{saxt.line}{the number of lines into the left margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the bottom margin at which the
module names will be drawn.}

\item{legend.position}{the distance from the plot to start the legend, as a
proportion of the plot width.}

\item{legend.tick.size}{size of the ticks on the axis legend.}

\item{laxt.line}{the distance from the legend to render the legend axis
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the gene and sample names.}

\item{cex.lab}{relative size of the module names and legend titles.}

\item{cex.main}{relative size of the plot titles.}

\item{symmetric}{logical; controls whether the coexpression and adjacency
heatmaps are drawn as symmetric (square) heatmaps or asymettric triangle
heatmaps. If symmetric, then the gene and module names will also be rendered
on the left axis.}

\item{drawBorders}{logical; if \code{TRUE}, borders are drawn around the bars
in \code{plotModuleMembership}, \code{plotConnectivity}, and
\code{plotSummaryExpression}.}

\item{horizontal}{logical; controls whether the legend is rendered
 horizontally or vertically when using \code{plotExpressionLegend},
 \code{plotCoexpressionLegend} or \code{plotAdjacencyLegend}.}
}
\description{
Functions for plotting the topology of a network module.

\code{plotExpression:} Plot a heatmap of the gene expression for one or more
network modules in their discovery dataset, or an independent test dataset.

\code{plotCoexpression:} Plot a heatmap of the gene coexpression for one or more
network modules in their discovery dataset, or an independent test dataset.

\code{plotAdjacency:} Plot a heatmap of the gene adjacencies for one or more
network modules in their discovery dataset, or an independent test dataset.

\code{plotModuleMembership:} Plot a bar chart of the module membership for
one or more network modules in their discovery dataset, or an independent
test dataset.

\code{plotConnectivity:} Plot a bar chart of the normalised intramodular
connectivity (see details) for one or more network modules in their discovery
dataset, or an independent test dataset.

\code{plotSummaryExpression:} Plot bar charts of the summary expression
profiles of one or more network modules in their discovery dataset, or an
independent test dataset.

\code{plotExpressionLegend:} Plot a legend for the gene expression heatmap
for one or more network modules in their discovery dataset, or an independent
test dataset.

\code{plotCoexpressionLegend:} Plot a legend for the gene coexpression.

\code{plotAdjacencyLegend:} Plot a legend for the gene adjacencies.
}
\details{
\subsection{Input data structure:}{
  This function allows for input data formatted in a number of ways. Where
  there are multiple datasets of interest (e.g. multiple tissues, or a
  discovery dataset and an independent test dataset) the arguments
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} should be
  \code{\link[=list]{lists}} where each element contains the matrix data for
  each respective dataset. This matrix data should be stored as a 'bigMatrix'
  object (see \link[=bigMatrix-get]{converting matrix data to 'bigMatrix'
  data}). Alternatively, if only one dataset is of interest, the
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} arguments
  will also each accept a single 'bigMatrix' object.

  Similarly, the \code{moduleAssignments} argument expects a list of named
  vectors, which contain the the module assignments for each gene in the
  respective dataset. List elements corresponding to datasets where module
  discovery has not been performed should contain \code{NULL}, unless the
  datasets are named throughout the function arguments. I.e. where the
  \code{\link{names}} of \code{geneExpression}, \code{coexpression}, and
  \code{adjacency} correspond to the names of each dataset of interest, the
  names of the \code{discovery} dataset can be used to look up the respective
  module assignments in the \code{moduleAssignments} list. If module
  discovery has only been performed in one dataset, then the
  \code{moduleAssignments} will also accept a named vector.

  The \code{discovery} arguments specifies which dataset the \code{modules}
  of interest were discovered in, and the \code{test} argument specifies
  which dataset to plot those module(s) in. The \code{orderGenesBy} and
  \code{orderSamplesBy} arguments control how genes and samples are ordered
  on the plot. These arguments are ignored if data is provided for only one
  dataset.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link[=bigMatrix-class]{bigMatrix}}
  data, regular 'matrix' objects are also accepted. In this case, the
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on
  disk, which can take a long time for large datasets. It is strongly
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link{networkProperties} function,
  \link[=plotModule]{plotting} \link[=plotTopology]{functions},
  \link[=geneOrder]{gene} and \link[=sampleOrder]{sample} ordering also
  expect 'bigMatrix' objects. Further, 'bigMatrix' objects have a number of
  benefits, including instantaneous load time from any future R session, and
  parallel access from mutliple independent R sessions. Methods are provided
  for \link[=bigMatrix-get]{converting to, loading in}, and
  \link[=bigMatrix-out]{writing out} 'bigMatrix' objects.
}
\subsection{Gene and sample ordering:}{
  By default, genes are ordered in decreasing order of intramodular
  connectivity in the \code{discovery} dataset (see \code{\link{geneOrder}}).
  This facilitates the visual comparison of modules across datasets, as the
  gene ordering will be preserved. Missing genes are colored in grey. This
  behaviour can be change by setting \code{orderGenesBy} to "test", in which
  cases genes will be ordered in decreasing order of intramodular
  connectivity in the discovery dataset. Alternatively \code{orderGenesBy}
  can be set to "none", in which case genes are rendered in the order they
  appear in the discovery dataset.

  When multiple modules are specified, modules are ordered by the similarity
  of their summary expression profiles in the \code{orderGenesBy} dataset.
  To disable this behaviour, set \code{orderModules} to \code{FALSE}.

  Sample ordering only applies to \code{plotExpression} and
  \code{plotSummaryExpression}. By default, samples are ordered in descending
  order of the summary expression profile for the left-most module appearing
  on the plot (see \code{\link{sampleOrder}}. By default, the summary
  expression profile is calculated in the \code{test} dataset. This behaviour
  can be changed through the \code{orderSamplesBy} argument, however setting
  \code{orderSamplesBy} to "discovery" will only work if samples are present
  in both datasets.
}
\subsection{Normalised intramodular connectivity:}{
  The gene connectivity is normalised by the maximum connectivity in any
  given module when rendered on the bar plot. This facilitates visual
  comparison on genes within a module when multiple modules of differing
  sizes or densities are rendered. Further, although the relative
  intramodular connectivity provides information about a genes biological
  importance to a module \emph{(1)}, the numeric value is meaningless.
  Normalising the connectivity is therefore useful for visual inspection.
}
\subsection{Customising plot layout:}{
  Although reasonable default values for most parameters have been provided,
  the rendering of axes and titles may need adjusting depending on the size
  of the plot window. The parameters \code{gaxt.line}, \code{saxt.line},
  \code{maxt.line}, and \code{laxt.line} control the distance from each plot
  window that the gene labels, sample labels, module labels, and legend
  labels are rendered.

  \code{legend.tick.size} controls the length of the
  axis ticks on each of the legends relative to the coexpression, adjacency,
  and gene expression plot windows.

  \code{legend.position} controls the horizontal offset of the legend
  relative to the plot. For the triangle heatmaps, (\code{symmetric=FALSE} in
  \code{plotCoexpression} and \code{plotAdjacency}) this controls how far
  left of the plot the legend starts as a proportion of the plot width. For
  the square heatmaps (\code{plotExpression}, and \code{symmetric=TRUE} in
  \code{plotCoexpression} and \code{plotAdjacency}) this controls how far
  right of the plot the legend starts as a proportion of the plot width.

  \code{cex.main} controls the relative text size of the plot title
  (specified by the \code{main} argument). \code{cex.axis} controls the
  relative text size of the gene and sample labels. \code{cex.lab} controls
  the relative text size of the bar plot axis labels, module labels, and the
  legend titles.

  The rendering of gene, sample, and module names can be disabled by setting
  \code{plotGeneNames}, \code{plotSampleNames}, and \code{plotModuleNames} to
  \code{FALSE}, and the rendering of the legend can be disabled by setting
  \code{plotLegend} to \code{FALSE}

  The \code{drawBorders} argument controls whether borders are drawn around
  the bars in \code{plotConnectivity}, \code{plotModuleMembership}, and
  \code{plotSummaryExpression}.
}
\subsection{Customising the color palette:}{
  \code{plotCoexpression} and \code{plotCoexpressionLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the coexpression. They expect the first element of the
  \code{palette} vector to be the color used for coexpression values of -1,
  and the last element of the \code{palette} vector to be the color used for
  coexpression values of 1.

  \code{plotAdjacency} and \code{plotAdjacencyLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the adjacencies. They expect the first element of the
  \code{palette} vector to be the color used for gene adjacency values of 0,
  and the last element of the \code{palette} vector to be the color used for
  coexpression values of 1.

  \code{plotConnectivity} expects \code{palette} to be a single color, a
  vector of colors, one for each gene, or a vector of colors to be repeated.

  \code{plotModuleMembership} expects \code{palette} to be a vector
  containing two colors, the first to be used for genes with negative module
  membership values, and the second to be used for genes with positive module
  membership values.

  \code{plotExpression} and \code{plotExpressionLegend} expect the
  \code{palette} argument to be a vector of colors to interpolate over when
  plotting the gene expression. In order to accomodate gene expression values
  with dramatically different ranges, these functions expect the palette to
  be a diverging set of colors with a centre value corresponding the a gene
  expression value of 0 (e.g. white). The colors used will be balanced around
  0: i.e. positive and negative values of gene expression will have the same
  color intensity on a diverging color palette regardless of the actual
  range. For gene expression data not centred around 0 the tail of the vector
  will be used: the minimum gene expression value will receive the centre
  palette color, and the last element of the \code{palette} vector will be
  used for maximum gene expression value.

  \code{plotSummaryExpression} expects \code{palette} to be a vector
  containing two colors, the first to be used for genes with a negative
  summary expression profile, and the second to be used for genes with a
  positive summary expression profile, regardless of whether the gene
  expression is centred around 0.
}
}
\examples{
\dontrun{
## Create some example data
geA <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geA) <- paste0("Gene_", 1:100)
rownames(geA) <- paste0("CohortA_", 1:50)
coexpA <- cor(geA) # coexpression
adjA <- abs(coexpA)^5 # adjacency
moduleAssignments <- sample(1:7, size=100, replace=TRUE)
names(moduleAssignments) <- paste0("Gene_", 1:100)

# Create bigMatrix objects for each matrix.
geA <- as.bigMatrix(geA, "geA_bm")
coexpA <- as.bigMatrix(coexpA, "coexpA_bm")
adjA <- as.bigMatrix(adjA, "adjA_bm")

## Example 1: Plot Module 2 in cohort A.
plotExpression(geA, coexpA, adjA, moduleAssignments, modules="2")
plotCoexpression(geA, coexpA, adjA, moduleAssignments, modules="2")
# alternatively as a square heatmap
plotCoexpression(
 geA, coexpA, adjA, moduleAssignments, modules="2", symmetric=TRUE
)
plotAdjacency(geA, coexpA, adjA, moduleAssignments, modules="2")
plotConnectivity(geA, coexpA, adjA, moduleAssignments, modules="2")
plotModuleMembership(geA, coexpA, adjA, moduleAssignments, modules="2")
plotSummaryExpression(geA, coexpA, adjA, moduleAssignments, modules="2")

## Example 2: Plot an arbitrary set of genes in cohort A
plotExpression(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotCoexpression(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
# alternatively as a square heatmap
plotCoexpression(
 geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10], symmetric=TRUE
)
plotAdjacency(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotConnectivity(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotModuleMembership(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])
plotSummaryExpression(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])

## Example 3: Plot the topology of two adipose tissue modules in the liver
## tissue data

geAdipose <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geAdipose) <- paste0("Gene_", 1:100)
rownames(geAdipose) <- paste0("Sample_", 1:50)
coexpAdipose <- cor(geAdipose) # coexpression
adjAdipose <- abs(coexpAdipose)^5 # adjacency
adiposeModules <- sample(0:7, size=100, replace=TRUE)
names(adiposeModules) <- paste0("Gene_", 1:100)

geLiver <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geLiver) <- paste0("Gene_", 1:100)
rownames(geLiver) <- paste0("Sample_", 1:50)
coexpLiver <- cor(geLiver) # coexpression
adjLiver <- abs(coexpLiver)^6 # adjacency
liverModules <- sample(0:12, size=100, replace=TRUE)
names(liverModules) <- paste0("Gene_", 1:100)

geHeart <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geHeart) <- paste0("Gene_", 1:100)
rownames(geHeart) <- paste0("Sample_", 1:50)
coexpHeart <- cor(geHeart) # coexpression
adjHeart <- abs(coexpHeart)^4 # adjacency
heartModules <- sample(0:5, size=100, replace=TRUE)
names(heartModules) <- paste0("Gene_", 1:100)

# Store each input type as a list, where each element corresponds
# to one of the datasets
geneExpression <- list(
  adipose=as.bigMatrix(geAdipose, "geAdipose_bm"),
  liver=as.bigMatrix(geLiver, "geLiver_bm"),
  heart=as.bigMatrix(geHeart, "geHeart_bm")
)
coexpression <- list(
  adipose=as.bigMatrix(coexpAdipose, "coexpAdipose_bm"),
  liver=as.bigMatrix(coexpLiver, "coexpLiver_bm"),
  heart=as.bigMatrix(coexpHeart, "coexpHeart_bm")
)
adjacency <- list(
  adipose=as.bigMatrix(adjAdipose, "adjAdipose_bm"),
  liver=as.bigMatrix(adjLiver, "adjLiver_bm"),
  heart=as.bigMatrix(adjHeart, "adjHeart_bm")
)
moduleAssignments <- list(
  adipose=adiposeModules, liver=liverModules, heart=heartModules
)

# Show the plot
plotExpression(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotCoexpression(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
# alternatively as a square heatmap
plotCoexpression(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver", symmetric=TRUE
)
plotAdjacency(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotConnectivity(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotModuleMembership(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)
plotSummaryExpression(
 geneExpression, coexpression, adjacency, moduleAssignments,
 modules=c("3", "7"), discovery="adipose", test="liver"
)

# clean up bigMatrix files from examples
unlink("*_bm*")
}
}
\references{
\enumerate{
   \item{
     Langfelder, P., Mischel, P. S. & Horvath, S. \emph{When is hub gene
     selection better than standard meta-analysis?} PLoS One \strong{8},
     e61505 (2013).
   }
}
}
\seealso{
\code{\link{plotModule}} for a combined plot showing all topological
properties for a network module.
}

