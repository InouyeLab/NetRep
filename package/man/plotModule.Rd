% Generated by roxygen2 (4.0.2): do not edit by hand
\name{plotModule}
\alias{plotModule}
\title{Plot the topology of a gene coexpression module}
\usage{
plotModule(geneExpression, coexpression, adjacency, moduleAssignments, modules,
  discovery = 1, test = 1, orderSamplesBy = "test",
  orderGenesBy = "discovery", orderModules, plotGeneNames = TRUE,
  plotSampleNames = TRUE, plotModuleNames, main = "Module Topology",
  drawBorders = FALSE, gaxt.line = -0.5, saxt.line = -0.5, maxt.line,
  legend.tick.size = 0.04, laxt.line = 2.5, cex.axis = 0.8, cex.lab = 1,
  cex.main = 1.2)
}
\arguments{
\item{geneExpression}{optional; a list of
\code{\link[=bigMatrix-class]{bigMatrix}} objects, each containing the gene
expression data for a datset of interest (see details). Columns are
expected to be genes, rows samples. If not provided, the expression,
module membership, and summary expression will not be plotted.}

\item{coexpression}{a list of 'bigMatrix' objects, each containing the gene
coexpression for a dataset of interest (see details).}

\item{adjacency}{a list of 'bigMatrix' objects, each containing the gene
adjacencies for a dataset of interest (see details).}

\item{moduleAssignments}{a list of named vectors assigning genes to modules
in each dataset of interest (see details).}

\item{modules}{a vector of modules to apply the function to (see details).}

\item{discovery}{name or index denoting which dataset the module of interest
was discovered in (see details).}

\item{test}{name or index denoting which dataset to apply the function to
(see details).}

\item{orderSamplesBy}{one of "discovery", "test", or "none" indicating which
dataset the function should use to order the samples (see details).}

\item{orderGenesBy}{one of "discovery", "test", or "none" indicating which
dataset the function should use to order the genes (see details).}

\item{orderModules}{logical; if \code{TRUE} modules will be ordered by the
similarity of their summary expression profiles (see details). The default
is \code{TRUE} if gene expression for the \code{test} dataset is provided.}

\item{plotGeneNames}{logical; if \code{TRUE}, plot the gene names on the
bottom axis.}

\item{plotSampleNames}{logical; if \code{TRUE}, plot the sample names on the
left axis next to the summary expression profiles.}

\item{plotModuleNames}{logical; if \code{TRUE}, plot the module names on the
bottom axis and above the summary expression profiles. By default, the
module names are rendered only if multiple \code{modules} are specified.}

\item{main}{title for the plot.}

\item{drawBorders}{logical; if \code{TRUE}, borders are drawn around the
connectivity, module membership, and summary expression bar plots.}

\item{gaxt.line}{the number of lines into the bottom margin at which the gene
names will be drawn.}

\item{saxt.line}{the number of lines into the left margin at which the sample
names will be drawn.}

\item{maxt.line}{the number of lines into the bottom margin at which the
module names will be drawn.}

\item{legend.tick.size}{size of the ticks on each axis legend relative to the
size of the coexpression, adjacency, and gene expression heatmaps.}

\item{laxt.line}{the distance from the legend to render the legend axis
labels, as multiple of \code{legend.tick.size}.}

\item{cex.axis}{relative size of the gene and sample names.}

\item{cex.lab}{relative size of the module names, legend titles, and axis
labels.}

\item{cex.main}{relative size of the plot title.}
}
\description{
Plot the coexpression, adjacency, (normalised) intramodular connectivity,
module membership, gene expression, and summary expression profiles of one or
more network modules in the discovery dataset or independent test dataset.

Individual components of the module plot can be plotted using
\code{\link{plotCoexpression}}, \code{\link{plotAdjacency}},
\code{\link{plotConnectivity}}, \code{\link{plotModuleMembership}},
\code{\link{plotExpression}}, and \code{\link{plotSummaryExpression}}.
}
\details{
\subsection{Input data structure:}{
  This function allows for input data formatted in a number of ways. Where
  there are multiple datasets of interest (e.g. multiple tissues, or a
  discovery dataset and an independent test dataset) the arguments
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} should be
  \code{\link[=list]{lists}} where each element contains the matrix data for
  each respective dataset. This matrix data should be stored as a 'bigMatrix'
  object (see \link[=bigMatrix-get]{converting matrix data to 'bigMatrix'
  data}). Alternatively, if only one dataset is of interest, the
  \code{geneExpression}, \code{coexpression}, and \code{adjacency} arguments
  will also each accept a single 'bigMatrix' object.

  Similarly, the \code{moduleAssignments} argument expects a list of named
  vectors, which contain the the module assignments for each gene in the
  respective dataset. List elements corresponding to datasets where module
  discovery has not been performed should contain \code{NULL}, unless the
  datasets are named throughout the function arguments. I.e. where the
  \code{\link{names}} of \code{geneExpression}, \code{coexpression}, and
  \code{adjacency} correspond to the names of each dataset of interest, the
  names of the \code{discovery} dataset can be used to look up the respective
  module assignments in the \code{moduleAssignments} list. If module
  discovery has only been performed in one dataset, then the
  \code{moduleAssignments} will also accept a named vector.

  The \code{discovery} arguments specifies which dataset the \code{modules}
  of interest were discovered in, and the \code{test} argument specifies
  which dataset to plot those module(s) in. The \code{orderGenesBy} and
  \code{orderSamplesBy} arguments control how genes and samples are ordered
  on the plot. These arguments are ignored if data is provided for only one
  dataset.
}
\subsection{'bigMatrix' vs. 'matrix' input data:}{
  Although the function expects \code{\link[=bigMatrix-class]{bigMatrix}}
  data, regular 'matrix' objects are also accepted. In this case, the
  'matrix' data is temporarily converted to 'bigMatrix' by the function. This
  conversion process involves writing out each matrix as a binary file on
  disk, which can take a long time for large datasets. It is strongly
  recommended for the user to store their data as 'bigMatrix' objects, as the
  \link{modulePreservation} function, \link{networkProperties} function,
  \link[=plotModule]{plotting} \link[=plotTopology]{functions},
  \link[=geneOrder]{gene} and \link[=sampleOrder]{sample} ordering also
  expect 'bigMatrix' objects. Further, 'bigMatrix' objects have a number of
  benefits, including instantaneous load time from any future R session, and
  parallel access from mutliple independent R sessions. Methods are provided
  for \link[=bigMatrix-get]{converting to, loading in}, and
  \link[=bigMatrix-out]{writing out} 'bigMatrix' objects.
}
\subsection{Gene and sample ordering:}{
  By default, genes are ordered in decreasing order of intramodular
  connectivity in the \code{discovery} dataset (see \code{\link{geneOrder}}).
  This facilitates the visual comparison of modules across datasets, as the
  gene ordering will be preserved. Missing genes are colored in grey. This
  behaviour can be change by setting \code{orderGenesBy} to "test", in which
  cases genes will be ordered in decreasing order of intramodular
  connectivity in the discovery dataset. Alternatively \code{orderGenesBy}
  can be set to "none", in which case genes are rendered in the order they
  appear in the discovery dataset.

  When multiple modules are specified, modules are ordered by the similarity
  of their summary expression profiles in the \code{orderGenesBy} dataset.
  To disable this behaviour, set \code{orderModules} to \code{FALSE}.

  By default, samples are ordered in descending order of the summary
  expression profile for the left-most module appearing on the plot (see
  \code{\link{sampleOrder}}. By default, the summary expression profile is
  calculated in the \code{test} dataset. This behaviour can be changed
  through the \code{orderSamplesBy} argument, however setting
  \code{orderSamplesBy} to "discovery" will only work if samples are present
  in both datasets.
}
\subsection{Normalised intramodular connectivity:}{
  The gene connectivity is normalised by the maximum connectivity in any
  given module when rendered on the bar plot. This facilitates visual
  comparison on genes within a module when multiple modules of differing
  sizes or densities are rendered. Further, although the relative
  intramodular connectivity provides information about a genes biological
  importance to a module \emph{(1)}, the numeric value is meaningless.
  Normalising the connectivity is therefore useful for visual inspection.
}
\subsection{Plot customisation:}{
  Although reasonable default values for most parameters have been provided,
  the rendering of axes and titles may need adjusting depending on the size
  of the plot window. The parameters \code{gaxt.line}, \code{saxt.line},
  \code{maxt.line}, and \code{laxt.line} control the distance from each plot
  window that the gene labels, sample labels, module labels, and legend
  labels are rendered.

  \code{legend.tick.size} controls the length of the
  axis ticks on each of the legends relative to the coexpression, adjacency,
  and gene expression plot windows.

  \code{cex.main} controls the relative text size of the plot title
  (specified by the \code{main} argument). \code{cex.axis} controls the
  relative text size of the gene and sample labels. \code{cex.lab} controls
  the relative text size of the bar plot axis labels, module labels, and the
  legend titles.

  The rendering of gene, sample, and module names can be disabled by setting
  \code{plotGeneNames}, \code{plotSampleNames}, and \code{plotModuleNames} to
  \code{FALSE}.

  The \code{drawBorders} argument controls whether borders are drawn around
  the connectivity, module membership, or summary expression bar plots.
}
}
\examples{
\dontrun{
## Create some example data
geA <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geA) <- paste0("Gene_", 1:100)
rownames(geA) <- paste0("CohortA_", 1:50)
coexpA <- cor(geA) # coexpression
adjA <- abs(coexpA)^5 # adjacency
moduleAssignments <- sample(1:7, size=100, replace=TRUE)
names(moduleAssignments) <- paste0("Gene_", 1:100)

# Create bigMatrix objects for each matrix.
geA <- as.bigMatrix(geA, "geA_bm")
coexpA <- as.bigMatrix(coexpA, "coexpA_bm")
adjA <- as.bigMatrix(adjA, "adjA_bm")

## Example 1: Plot Module 2 in cohort A.
plotModule(geA, coexpA, adjA, moduleAssignments, modules="2")

## Example 2: Plot an arbitrary set of genes in cohort A
plotModule(geA[,1:10], coexpA[1:10, 1:10], adjA[1:10, 1:10])

## Example 3: Plot the topology of two adipose tissue modules in the liver
## tissue data

geAdipose <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geAdipose) <- paste0("Gene_", 1:100)
rownames(geAdipose) <- paste0("Sample_", 1:50)
coexpAdipose <- cor(geAdipose) # coexpression
adjAdipose <- abs(coexpAdipose)^5 # adjacency
adiposeModules <- sample(0:7, size=100, replace=TRUE)
names(adiposeModules) <- paste0("Gene_", 1:100)

geLiver <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geLiver) <- paste0("Gene_", 1:100)
rownames(geLiver) <- paste0("Sample_", 1:50)
coexpLiver <- cor(geLiver) # coexpression
adjLiver <- abs(coexpLiver)^6 # adjacency
liverModules <- sample(0:12, size=100, replace=TRUE)
names(liverModules) <- paste0("Gene_", 1:100)

geHeart <- matrix(rnorm(50*100), ncol=100) # gene expression
colnames(geHeart) <- paste0("Gene_", 1:100)
rownames(geHeart) <- paste0("Sample_", 1:50)
coexpHeart <- cor(geHeart) # coexpression
adjHeart <- abs(coexpHeart)^4 # adjacency
heartModules <- sample(0:5, size=100, replace=TRUE)
names(heartModules) <- paste0("Gene_", 1:100)

# Store each input type as a list, where each element corresponds
# to one of the datasets
geneExpression <- list(
  adipose=as.bigMatrix(geAdipose, "geAdipose_bm"),
  liver=as.bigMatrix(geLiver, "geLiver_bm"),
  heart=as.bigMatrix(geHeart, "geHeart_bm")
)
coexpression <- list(
  adipose=as.bigMatrix(coexpAdipose, "coexpAdipose_bm"),
  liver=as.bigMatrix(coexpLiver, "coexpLiver_bm"),
  heart=as.bigMatrix(coexpHeart, "coexpHeart_bm")
)
adjacency <- list(
  adipose=as.bigMatrix(adjAdipose, "adjAdipose_bm"),
  liver=as.bigMatrix(adjLiver, "adjLiver_bm"),
  heart=as.bigMatrix(adjHeart, "adjHeart_bm")
)
moduleAssignments <- list(
  adipose=adiposeModules, liver=liverModules, heart=heartModules
)

# Show the plot
plotModule(
  geneExpression, coexpression, adjacency, moduleAssignments,
  modules=c("3", "7"), discovery="adipose", test="liver"
)

# clean up bigMatrix files from examples
unlink("*_bm*")
}
}
\references{
\enumerate{
   \item{
     Langfelder, P., Mischel, P. S. & Horvath, S. \emph{When is hub gene
     selection better than standard meta-analysis?} PLoS One \strong{8},
     e61505 (2013).
   }
}
}
\seealso{
\code{\link{plotCoexpression}}
\code{\link{plotAdjacency}}
\code{\link{plotConnectivity}}
\code{\link{plotModuleMembership}}
\code{\link{plotExpression}}
\code{\link{plotSummaryExpression}}
}

