#' Plot Subset legend
#' 
#' Render a horizontal bar that demarcates where nodes in the 
#' figure generated by \code{\link{PlotNetworkHeatmap}} fall.
#' 
#' 
PlotSubsetLegend <- function(node.labels) {
  gradient.bar(range        = c(0, ncol(edge.matrix)), 
               break.points = break.points,
               col          = cluster.cols,
               bin.lab      = breaks$values,
               main         = cluster.legend.main,
               direction    = "x",
               lines        = NA)
}



#' Plot Edge Weight legend

#' Plot network edge weights as a heatmap.
#'
#' Plots the edge weights between nodes as a heatmap, optionally drawing boxes 
#' around pre-determined clusters. The \code{xlab} and \code{ylab} arguments are
#' useful when comparing the edge weights.
#'
#' @param edge.matrix a square matrix containing the edge weights between each
#'                    pair of nodes.
#' @param network.labels an optional named vector assigning each node to a 
#'                       network/cluster.
#' @param xlab x-axis heatmap label.
#' @param ylab y-axis heatmap label.
#' @param node.labels a character vector of labels to print for each row/column
#'                    cell.
#' @param legend.main title to give to the legend denoting heatmap colors.
#' @param cluster.legend.main title to give to the legend denoting cluster 
#'        assignment.
#' @param legend.bins Number of bins to partition heatmap colors into on the
#'        legend. Colors on the heatmap itself are unaffected by this. Colors
#'        are interpolated over the \code{heatmap.gradient}.
#' @param edge.weight.range The range of values edge weights can take. Defaults
#'        to \code{c(-1, 1)}.
#' @param heatmap.gradient A vector of colors to use for (or interpolate over)
#'        the heatmap.bins.
#' @param cluster.cols an optional vector of colors for denoting each cluster 
#'        on a legend.
#' @param mar outside margins of the plot
#' @param gap.width the margin size in lines between the heatmap, and the 
#'        \code{cluster.legend}
#' @param layout.heights relative proportion of the plot that the heatmap
#'        takes up compared to the cluster labelling. Useful if your cluster
#'        labels are large. Must sum to 1.
#' @note 
#'  It expects nodes to be pre-ordered within the edge weight matrix:
#'  I.e. clusters should be in continuous blocks. Otherwise, garbage-in, 
#'  garbage-out.
#'
#' @export
PlotNetworkHeatmap <- function(edge.matrix, network.labels=NULL, 
                               xlab="", ylab="", node.labels=NULL, 
                               legend.main="", cluster.legend.main="",
                               legend.bins=11, edge.weight.range=c(-1,1),
                               heatmap.gradient, cluster.cols, 
                               mar=c(5.1,4.1,2.1,2.1), gap.width=2.1, 
                               layout.heights=c(0.85, 0.15),...) {
  if(missing(heatmap.gradient)) {
    # "RdYlBu" RColorBrewer palette, with the middle value replaced with white:
    # this gives a nicer contrast than he RdBu palette.
    heatmap.gradient <- c("#313695", "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8",
                          "#FFFFFF", "#FEE090", "#FDAE61", "#F46D43", "#D73027", 
                          "#A50026")
  }
  
  # Find where one network cluster changes to the next:
  if (!is.null(network.labels)) {

  }
  
  # Render edge.matrix heatmap
  if(!is.null(network.labels)) {
    stopifnot(sum(layout.heights) == 1)
    layout(matrix(1:4, ncol=2, byrow=TRUE), widths=c(0.85, 0.15),
           heights=layout.heights)
  } else {
    layout(matrix(1:2, ncol=2, byrow=TRUE), widths=c(0.85, 0.15))
  }
  h.gap = ifelse(!is.null(node.labels) & xlab != "", 2.1, 1.6)
  par(mar=c(ifelse(is.null(network.labels), mar[1], gap.width),mar[2],mar[3],h.gap), ...)
  image(x      = 0:ncol(edge.matrix),
        y      = 0:ncol(edge.matrix),
        z      = edge.matrix,
        col    = colorRampPalette(heatmap.gradient)(255),
        breaks = seq(edge.weight.range[1], edge.weight.range[2],
                     length.out=255+1),
        axes   = FALSE,
        xlab   = "",
        ylab   = "",
        ...)
  abline(0, 1, col="black")
  
  if (!is.null(node.labels)) {
    axis(1, 1:ncol(edge.matrix)-0.5, node.labels, las=2, pos=0, ...)
    axis(2, 1:ncol(edge.matrix)-0.5, node.labels, las=2, pos=0, ...)
    mtext(xlab, side=4, line=0.5, ...)
    mtext(ylab, side=3, line=0.5, ...)
  } else {
    mtext(xlab, side=1, line=0.5, ...)
    mtext(ylab, side=2, line=0.5, ...)
  }
  
  # Draw boxes around network clusters
  if(!is.null(network.labels)) {
    lines(rect(0, 0, ncol(edge.matrix), ncol(edge.matrix), lwd=1))  # heatmap border
    for (i in 2:length(break.points)) {
      lines(rect(xleft   = break.points[i-1],
                 ybottom = break.points[i-1],
                 xright  = break.points[i],
                 ytop    = break.points[i],
                 lwd     = 1 
      ))  
    }
  }
  
  # Plot edge.matrix Legend
  par(mar=c(ifelse(is.null(network.labels), mar[1], gap.width+8), 4.1, mar[3]+2, mar[4]), ...)
  gradient.bar(nBins        = legend.bins, 
               direction    = "y", 
               lines        = "black", 
               col.gradient = rev(heatmap.gradient), 
               bin.lab      = format(seq(edge.weight.range[2], 
                                         edge.weight.range[1], 
                                         length=heatmap.bins+1), digits=2)
  )
  mtext(legend.main, side=3, line=0, ...)
}

#' Order genes and modules in a network
#' 
#' Clusters network modules by summary expression profile similarity, and 
#' order genes within each subset by connectivity.
#' 
#' @param adjacency Matrix of node adjacencies
#' @param module.labels Optional vector of module assignments for each gene.
#' @param summary.exp Optional \code{data.frame} of summary expression profiles
#'  for each network subset. 
#'  
#' @return a vector of ordered nodes. 
#'
#' @export
orderNetwork <- function(adjacency, module.labels=NULL, summary.exp=NULL) {
  adjacency <- dynamicMatLoad(adjacency)
  if (nrow(adjacency) != ncol(adjacency))
    stop("expecting a square adjacency!")
  
  nGenes <- nrow(adjacency)
  order <- NULL
  
  
  if (is.null(module.labels)) {
    module.labels = rep("a", nGenes)
    module.order = "a"
  } else {
    if (!is.null(summary.exp)) {
      h <- hclust(
        as.dist(
          1 - abs(cor(summary.exp, use="pairwise.complete.obs"))
        )
      )
      module.order <- h$label[h$order]
    } else {
      module.order <- unique(module.labels)
      tryCatch({
        # attempt to order numerically if possible
        module.order <- module.order[order(as.integer(module.order))]
      }, warning = function(w) {
        # leave order as is
      })
    }
  }
  
  for (module in module.order) {
    module.nodes <- which(module.labels == module)
    
    # Order genes within each module by their connectivity to all other genes
    kIM <- adjProps(adjacency, module.nodes)$kIM
    order <- c(order, module.nodes[order(kIM, decreasing=TRUE)])
  }   
  
  return(order)
}

#' Coexpression plot
#' 
#' Plot a triangle of the coexpression
#' 
#' @param coexpresion a square matrix containing the pairwise gene coexpression.
#' @param module.labels an optional named vector assigning each node to a module.
#' @param heatmap.gradient A vector of colors to use for (or interpolate over)
#'        the heatmap.bins.
#' @export
plotCoexpression <- function(
  coexpression, module.labels=NULL, heatmap.gradient
) {
  coexpression <- dynamicMatLoad(coexpression)
  if (nrow(coexpression) != ncol(coexpression))
    stop("expecting a square edge.matrix!")
  
  nGenes <- nrow(coexpression)
  
  if(missing(heatmap.gradient)) {
    heatmap.gradient <- custom.palette()
  }
  nColBins <- 255 
  colGrad <- colorRampPalette(heatmap.gradient)(nColBins)
  edgeBins <- seq(-1, 1, length=nColBins+1)
  
  # create empty plot window
  xlim <- getLimsForManualUsr(c(0, nGenes))
  ylim <- getLimsForManualUsr(c(0, nGenes/2))
  plot(
    0, type='n', xaxt='n', yaxt='n', xlim=xlim, ylim=ylim, xlab="", ylab="", 
    frame.plot = FALSE
  )
  
  # render correlation squares / triangles
  for (ii in 1:nGenes) {
    for (jj in 1:ii) {
      plotRow <- ii - jj
      topy <- (plotRow + 1)/2
      # If we're on the diagonal, plot a triangle, otherwise a diamond
      if (plotRow == 0) {
        boty <- 0
      } else {
        boty <- topy - 1
      }
      xOffset <- plotRow/2
      rightx <- jj + xOffset
      leftx <- rightx - 1
      
      polygon(
        x=c(leftx, leftx+0.5, rightx, leftx+0.5, leftx),
        y=c(topy-0.5, topy, topy-0.5, boty, topy-0.5),
        col=findColInGrad(coexpression[ii, jj], edgeBins, colGrad),
        border=NA
      )
    }
  }
  
  # render module boundaries
  if (!is.null(module.labels)) {
    breaks <- getModuleBreaks(module.labels)
    for (mm in 2:length(breaks)) {
      mheight <- (breaks[mm] - breaks[mm - 1])/2
      halfway <-  mheight + breaks[mm - 1]
      polygon(
        x=c(breaks[mm - 1], breaks[mm], halfway, breaks[mm - 1]),
        y=c(0, 0, mheight, 0)
      )
    }
  }
  
  # render border of plot
  polygon(x=c(0, nGenes, nGenes/2, 0), y=c(0, 0, nGenes/2, 0))
  
}

# Get edge weight color from gradient.
# 
# Expects `edgeBins` to be in ascending order, and `edgeBins` to be 1 longer 
# than `colors`.
#
findColInGrad <- function(weight, edgeBins, colors) {  
  # Handle cases where edge weight is outside range
  if (weight <= edgeBins[1]){
    return(colors[1])
  }
  if (weight >= tail(edgeBins, 1)) {
    return(tail(colors, 1))
  }
  # Search for bin weight falls into
  for (i in 1:(length(edgeBins) - 1)) {
    if (weight >= edgeBins[i] & weight <= edgeBins[i + 1]) {
      return(colors[i])
    }
  }
}

#' Modified Brewer Palette
#' 
#' RColorBrewer palette "RdYlBu" with the middle color replaced with white. This
#' gives a nicer contrast than the "RdBu" palette
#' 
custom.palette <- function() {
  c(
    "#313695", "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FFFFFF", "#FEE090", 
    "#FDAE61", "#F46D43", "#D73027", "#A50026"
   )
}

#' Get the plot limits to set for the desired plot window
#'
#' \code{plot} manually adds an extra region to the plot on top of the given
#' 'xlim' and 'ylim', amounting to 4% of the plot region in either direction.
#' This function tells you what limits to set so that the boundaries of the plot
#' are precisely the min and max you want.
#' 
#' @param dlim the limits you want to set
#' @return
#'  the min and max to set for the desired plot limits  
getLimsForManualUsr <- function(dlim) {
  A = matrix(c(1.04, -0.04, -0.04, 1.04), nrow=2, ncol=2)
  B = matrix(dlim, nrow=2, ncol=1)
  as.vector(solve(A, B))
}

# Identifies the break points between modules on the x axis.
getModuleBreaks <- function(module.labels) {
  breaks <- rle(module.labels)
  break.points <- sapply(1:length(breaks$length), function(i) {
    sum(breaks$length[1:i])
  })  
  break.points <- c(0, break.points)
  break.points
}
