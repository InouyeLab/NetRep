# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Check the elements of a `big.matrix`
#' 
#' Are all the values finite? 
#' 
#' @param pDat SEXP container for the pointer to the 
#'   \code{\link[bigmemory]{big.matrix}} to be checked.
#'
#' @rdname chekcFinite-cpp
CheckFinite <- function(pDat) {
    invisible(.Call('netrep_CheckFinite', PACKAGE = 'netrep', pDat))
}

#' Network subset eigenvector and proportion of variance explained in C++
#' 
#' @param pDat SEXP container for the pointer to the data matrix used in 
#'   network construction.
#' @param pScaledDat SEXP container for the pointer to a scaled version of the 
#'   data matrix used to construct the network.
#' @param subsetIndices indices of the network subset of interest in 
#'   \code{pDat}.
#' 
#' @return
#'  A list containing:
#'  \enumerate{
#'   \item{\emph{"kME"}:}{
#'     The subset kME for each node  (see details).
#'   }
#'   \item{\emph{"propVarExplained"}:}{
#'     The proportion of the variance explained by the subset's summary
#'     vector (see details).
#'   }
#'  }
#'
#' @references
#'   \enumerate{
#'     \item{
#'       Langfelder, P., Luo, R., Oldham, M. C. & Horvath, S. \emph{Is my 
#'       network module preserved and reproducible?} PLoS Comput. Biol. 
#'       \strong{7}, e1001057 (2011). 
#'     }
#'  }
#'  
#' @details
#'  First, a summary vector is calculated for the network subset from the 
#'  underlying data. This is the first right singular vector from a singular 
#'  value decomposition (also the eigenvector of the first principal component 
#'  \emph{(1)}). The sign of the returned eigenvector is modified to match the
#'  average of \code{pDat}. This is to match the behaviour of
#'  \emph{moduleEigengenes} in the \code{WGCNA} package.
#'  
#'  Using this summary vector, the subset kME of each node is quantified
#'  as the correlation between that node's data, and the summary vector.
#'  
#'  The proportion of variance explained by this summary vector is quantified
#'  as the average square of the subset kMEs for all nodes in the 
#'  network subset.
#' 
#' @import RcppArmadillo
#' @rdname dataProps-cpp
#'  
DataProps <- function(pDat, pScaledDat, subsetIndices) {
    .Call('netrep_DataProps', PACKAGE = 'netrep', pDat, pScaledDat, subsetIndices)
}

#' big.matrix diagonals
#' 
#' @param pBigMat a \code{numeric} \code{\link[bigmemory]{big.matrix}}
#' @return a vector containing the diagonal of \code{pBigMat}
GetDiag <- function(pBigMat) {
    .Call('netrep_GetDiag', PACKAGE = 'netrep', pBigMat)
}

#' big.matrix diagonals
#' 
#' @param pBigMat a \code{numeric} \code{\link[bigmemory]{big.matrix}}
#' @param value either a single \code{numeric} value or \code{numeric} vector 
#'   of length equal to the current diagonal.
SetDiag <- function(pBigMat, value) {
    invisible(.Call('netrep_SetDiag', PACKAGE = 'netrep', pBigMat, value))
}

#' Calculate Network Properties
#'
#' @param pAdjacency SEXP container for the pointer to the adjacency matrix
#' @param subsetIndices indices of the subset of the network to calculate
#'   the mean adjacency for.
#'   
#' @return
#'   A List containing:
#'   \enumerate{
#'     \item{\emph{kIM}:}{The weighted within-subset degree for each node.}
#'     \item{\emph{MAR}:}{The maximum adjacency ratio for each node.}
#'     \item{\emph{meanAdj}:}{The mean absolute edge weight of the network subset.}
#'     \item{\emph{meanKIM}:}{The mean within-subset degree.}
#'     \item{\emph{meanMAR}:}{The mean maximum adjacency ratio.}
#'   }
#' @rdname netProps-cpp
NetProps <- function(pAdjacency, subsetIndices) {
    .Call('netrep_NetProps', PACKAGE = 'netrep', pAdjacency, subsetIndices)
}

#' Calculate Network Statistics
#'
#' For some statistics it does not make sense to calculate the necessary
#' components in advance due to large memory overhead, or logic that doesn't
#' separate nicely. This function deals with those statistics.
#'
#' @param pAdjD,pAdjT SEXP containers for the pointers to the
#'  \code{\link[bigmemory]{big.matrix}} objects holding the \emph{discovery}
#'  and \emph{test} networks respectively.
#' @param discIndices,testIndices indices of the network subset of interest in
#'   the \emph{discovery} and \emph{test} networks respectively.
#'
#' @return
#'   A vector containing:
#'   \enumerate{
#'     \item{\emph{cor.adj}:}{
#'       The correlation between the edge weights for both networks.
#'     }
#'   }
#' @rdname netStats-cpp
NetStats <- function(pAdjD, discIndices, pAdjT, testIndices) {
    .Call('netrep_NetStats', PACKAGE = 'netrep', pAdjD, discIndices, pAdjT, testIndices)
}

#' Scale a matrix by its rows
#' 
#' @param pDat SEXP container for the pointer to the data matrix to be scaled.
#' @param spDat SEXP container for the pointer to the pre-initialised
#'   \code{\link[bigmemory]{big.matrix}} that the scaled version of \code{pDat}
#'   will be stored in.
#' @rdname scale-cpp
Scale <- function(pDat, spDat) {
    invisible(.Call('netrep_Scale', PACKAGE = 'netrep', pDat, spDat))
}

